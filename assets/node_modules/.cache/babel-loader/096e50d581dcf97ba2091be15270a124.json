{"ast":null,"code":"/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType, isRequiredArgument, isRequiredInputField } from '../type/definition';\nimport keyMap from '../jsutils/keyMap';\nexport var BreakingChangeType = {\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  REQUIRED_ARG_ADDED: 'REQUIRED_ARG_ADDED',\n  REQUIRED_INPUT_FIELD_ADDED: 'REQUIRED_INPUT_FIELD_ADDED',\n  INTERFACE_REMOVED_FROM_OBJECT: 'INTERFACE_REMOVED_FROM_OBJECT',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED',\n  REQUIRED_DIRECTIVE_ARG_ADDED: 'REQUIRED_DIRECTIVE_ARG_ADDED'\n};\nexport var DangerousChangeType = {\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE',\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  INTERFACE_ADDED_TO_OBJECT: 'INTERFACE_ADDED_TO_OBJECT',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  OPTIONAL_INPUT_FIELD_ADDED: 'OPTIONAL_INPUT_FIELD_ADDED',\n  OPTIONAL_ARG_ADDED: 'OPTIONAL_ARG_ADDED'\n};\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\n\nexport function findBreakingChanges(oldSchema, newSchema) {\n  return findRemovedTypes(oldSchema, newSchema).concat(findTypesThatChangedKind(oldSchema, newSchema), findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).breakingChanges, findTypesRemovedFromUnions(oldSchema, newSchema), findValuesRemovedFromEnums(oldSchema, newSchema), findArgChanges(oldSchema, newSchema).breakingChanges, findInterfacesRemovedFromObjectTypes(oldSchema, newSchema), findRemovedDirectives(oldSchema, newSchema), findRemovedDirectiveArgs(oldSchema, newSchema), findAddedNonNullDirectiveArgs(oldSchema, newSchema), findRemovedDirectiveLocations(oldSchema, newSchema));\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  return findArgChanges(oldSchema, newSchema).dangerousChanges.concat(findValuesAddedToEnums(oldSchema, newSchema), findInterfacesAddedToObjectTypes(oldSchema, newSchema), findTypesAddedToUnions(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).dangerousChanges);\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing an entire type.\n */\n\nexport function findRemovedTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr = Object.keys(oldTypeMap);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var typeName = _arr[_i];\n\n    if (!newTypeMap[typeName]) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED,\n        description: \"\".concat(typeName, \" was removed.\")\n      });\n    }\n  }\n\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to changing the type of a type.\n */\n\nexport function findTypesThatChangedKind(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr2 = Object.keys(oldTypeMap);\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var typeName = _arr2[_i2];\n\n    if (!newTypeMap[typeName]) {\n      continue;\n    }\n\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (oldType.constructor !== newType.constructor) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: \"\".concat(typeName, \" changed from \") + \"\".concat(typeKindName(oldType), \" to \").concat(typeKindName(newType), \".\")\n      });\n    }\n  }\n\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any\n * breaking or dangerous changes in the newSchema related to arguments\n * (such as removal or change of type of an argument, or a change in an\n * argument's default value).\n */\n\nexport function findArgChanges(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  var _arr3 = Object.keys(oldTypeMap);\n\n  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n    var typeName = _arr3[_i3];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n\n    var oldTypeFields = oldType.getFields();\n    var newTypeFields = newType.getFields();\n\n    var _arr4 = Object.keys(oldTypeFields);\n\n    for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n      var fieldName = _arr4[_i4];\n\n      if (!newTypeFields[fieldName]) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var oldArgDef = _step.value;\n          var newArgs = newTypeFields[fieldName].args;\n          var newArgDef = newArgs.find(function (arg) {\n            return arg.name === oldArgDef.name;\n          }); // Arg not present\n\n          if (!newArgDef) {\n            breakingChanges.push({\n              type: BreakingChangeType.ARG_REMOVED,\n              description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" was removed\")\n            });\n          } else {\n            var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);\n\n            if (!isSafe) {\n              breakingChanges.push({\n                type: BreakingChangeType.ARG_CHANGED_KIND,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed type from \") + \"\".concat(oldArgDef.type.toString(), \" to \").concat(newArgDef.type.toString())\n              });\n            } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {\n              dangerousChanges.push({\n                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed defaultValue\")\n              });\n            }\n          }\n        };\n\n        for (var _iterator = oldTypeFields[fieldName].args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          _loop();\n        } // Check if arg was added to the field\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        var _loop2 = function _loop2() {\n          var newArgDef = _step2.value;\n          var oldArgs = oldTypeFields[fieldName].args;\n          var oldArgDef = oldArgs.find(function (arg) {\n            return arg.name === newArgDef.name;\n          });\n\n          if (!oldArgDef) {\n            var argName = newArgDef.name;\n\n            if (isRequiredArgument(newArgDef)) {\n              breakingChanges.push({\n                type: BreakingChangeType.REQUIRED_ARG_ADDED,\n                description: \"A required arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            } else {\n              dangerousChanges.push({\n                type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n                description: \"An optional arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            }\n          }\n        };\n\n        for (var _iterator2 = newTypeFields[fieldName].args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          _loop2();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n\n  throw new TypeError('Unknown type ' + type.constructor.name);\n}\n\nexport function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr5 = Object.keys(oldTypeMap);\n\n  for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n    var typeName = _arr5[_i5];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n\n    var _arr6 = Object.keys(oldTypeFieldsDef);\n\n    for (var _i6 = 0; _i6 < _arr6.length; _i6++) {\n      var fieldName = _arr6[_i6]; // Check if the field is missing on the type in the new schema.\n\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForObjectOrInterfaceField(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    }\n  }\n\n  return breakingChanges;\n}\nexport function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  var _arr7 = Object.keys(oldTypeMap);\n\n  for (var _i7 = 0; _i7 < _arr7.length; _i7++) {\n    var typeName = _arr7[_i7];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isInputObjectType(oldType) || !isInputObjectType(newType)) {\n      continue;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n\n    var _arr8 = Object.keys(oldTypeFieldsDef);\n\n    for (var _i8 = 0; _i8 < _arr8.length; _i8++) {\n      var fieldName = _arr8[_i8]; // Check if the field is missing on the type in the new schema.\n\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    } // Check if a field was added to the input object type\n\n\n    var _arr9 = Object.keys(newTypeFieldsDef);\n\n    for (var _i9 = 0; _i9 < _arr9.length; _i9++) {\n      var _fieldName = _arr9[_i9];\n\n      if (!(_fieldName in oldTypeFieldsDef)) {\n        if (isRequiredInputField(newTypeFieldsDef[_fieldName])) {\n          breakingChanges.push({\n            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n            description: \"A required field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        } else {\n          dangerousChanges.push({\n            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n            description: \"An optional field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        }\n      }\n    }\n  }\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isNamedType(oldType)) {\n    return (// if they're both named types, see if their names are equivalent\n      isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isListType(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return false;\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isNamedType(oldType)) {\n    // if they're both named types, see if their names are equivalent\n    return isNamedType(newType) && oldType.name === newType.name;\n  } else if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  } else if (isNonNullType(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  }\n\n  return false;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing types from a union type.\n */\n\n\nexport function findTypesRemovedFromUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesRemovedFromUnion = [];\n\n  var _arr10 = Object.keys(oldTypeMap);\n\n  for (var _i10 = 0; _i10 < _arr10.length; _i10++) {\n    var typeName = _arr10[_i10];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      continue;\n    }\n\n    var typeNamesInNewUnion = Object.create(null);\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = newType.getTypes()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var type = _step3.value;\n        typeNamesInNewUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = oldType.getTypes()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _type = _step4.value;\n\n        if (!typeNamesInNewUnion[_type.name]) {\n          typesRemovedFromUnion.push({\n            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n            description: \"\".concat(_type.name, \" was removed from union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  }\n\n  return typesRemovedFromUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding types to a union type.\n */\n\nexport function findTypesAddedToUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesAddedToUnion = [];\n\n  var _arr11 = Object.keys(newTypeMap);\n\n  for (var _i11 = 0; _i11 < _arr11.length; _i11++) {\n    var typeName = _arr11[_i11];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      continue;\n    }\n\n    var typeNamesInOldUnion = Object.create(null);\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = oldType.getTypes()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var type = _step5.value;\n        typeNamesInOldUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = newType.getTypes()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var _type2 = _step6.value;\n\n        if (!typeNamesInOldUnion[_type2.name]) {\n          typesAddedToUnion.push({\n            type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n            description: \"\".concat(_type2.name, \" was added to union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  }\n\n  return typesAddedToUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing values from an enum type.\n */\n\nexport function findValuesRemovedFromEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesRemovedFromEnums = [];\n\n  var _arr12 = Object.keys(oldTypeMap);\n\n  for (var _i12 = 0; _i12 < _arr12.length; _i12++) {\n    var typeName = _arr12[_i12];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      continue;\n    }\n\n    var valuesInNewEnum = Object.create(null);\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n\n    try {\n      for (var _iterator7 = newType.getValues()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n        var value = _step7.value;\n        valuesInNewEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError7 = true;\n      _iteratorError7 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n          _iterator7.return();\n        }\n      } finally {\n        if (_didIteratorError7) {\n          throw _iteratorError7;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      for (var _iterator8 = oldType.getValues()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _value = _step8.value;\n\n        if (!valuesInNewEnum[_value.name]) {\n          valuesRemovedFromEnums.push({\n            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n            description: \"\".concat(_value.name, \" was removed from enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n  }\n\n  return valuesRemovedFromEnums;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding values to an enum type.\n */\n\nexport function findValuesAddedToEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesAddedToEnums = [];\n\n  var _arr13 = Object.keys(oldTypeMap);\n\n  for (var _i13 = 0; _i13 < _arr13.length; _i13++) {\n    var typeName = _arr13[_i13];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      continue;\n    }\n\n    var valuesInOldEnum = Object.create(null);\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      for (var _iterator9 = oldType.getValues()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        var value = _step9.value;\n        valuesInOldEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion10 = true;\n    var _didIteratorError10 = false;\n    var _iteratorError10 = undefined;\n\n    try {\n      for (var _iterator10 = newType.getValues()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n        var _value2 = _step10.value;\n\n        if (!valuesInOldEnum[_value2.name]) {\n          valuesAddedToEnums.push({\n            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n            description: \"\".concat(_value2.name, \" was added to enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError10 = true;\n      _iteratorError10 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n          _iterator10.return();\n        }\n      } finally {\n        if (_didIteratorError10) {\n          throw _iteratorError10;\n        }\n      }\n    }\n  }\n\n  return valuesAddedToEnums;\n}\nexport function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr14 = Object.keys(oldTypeMap);\n\n  for (var _i14 = 0; _i14 < _arr14.length; _i14++) {\n    var typeName = _arr14[_i14];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      continue;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion11 = true;\n    var _didIteratorError11 = false;\n    var _iteratorError11 = undefined;\n\n    try {\n      var _loop3 = function _loop3() {\n        var oldInterface = _step11.value;\n\n        if (!newInterfaces.some(function (int) {\n          return int.name === oldInterface.name;\n        })) {\n          breakingChanges.push({\n            type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,\n            description: \"\".concat(typeName, \" no longer implements interface \") + \"\".concat(oldInterface.name, \".\")\n          });\n        }\n      };\n\n      for (var _iterator11 = oldInterfaces[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n        _loop3();\n      }\n    } catch (err) {\n      _didIteratorError11 = true;\n      _iteratorError11 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n          _iterator11.return();\n        }\n      } finally {\n        if (_didIteratorError11) {\n          throw _iteratorError11;\n        }\n      }\n    }\n  }\n\n  return breakingChanges;\n}\nexport function findInterfacesAddedToObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var interfacesAddedToObjectTypes = [];\n\n  var _arr15 = Object.keys(newTypeMap);\n\n  for (var _i15 = 0; _i15 < _arr15.length; _i15++) {\n    var typeName = _arr15[_i15];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      continue;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion12 = true;\n    var _didIteratorError12 = false;\n    var _iteratorError12 = undefined;\n\n    try {\n      var _loop4 = function _loop4() {\n        var newInterface = _step12.value;\n\n        if (!oldInterfaces.some(function (int) {\n          return int.name === newInterface.name;\n        })) {\n          interfacesAddedToObjectTypes.push({\n            type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,\n            description: \"\".concat(newInterface.name, \" added to interfaces implemented \") + \"by \".concat(typeName, \".\")\n          });\n        }\n      };\n\n      for (var _iterator12 = newInterfaces[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n        _loop4();\n      }\n    } catch (err) {\n      _didIteratorError12 = true;\n      _iteratorError12 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n          _iterator12.return();\n        }\n      } finally {\n        if (_didIteratorError12) {\n          throw _iteratorError12;\n        }\n      }\n    }\n  }\n\n  return interfacesAddedToObjectTypes;\n}\nexport function findRemovedDirectives(oldSchema, newSchema) {\n  var removedDirectives = [];\n  var newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n\n  try {\n    for (var _iterator13 = oldSchema.getDirectives()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var directive = _step13.value;\n\n      if (!newSchemaDirectiveMap[directive.name]) {\n        removedDirectives.push({\n          type: BreakingChangeType.DIRECTIVE_REMOVED,\n          description: \"\".concat(directive.name, \" was removed\")\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n\n  return removedDirectives;\n}\n\nfunction findRemovedArgsForDirective(oldDirective, newDirective) {\n  var removedArgs = [];\n  var newArgMap = getArgumentMapForDirective(newDirective);\n  var _iteratorNormalCompletion14 = true;\n  var _didIteratorError14 = false;\n  var _iteratorError14 = undefined;\n\n  try {\n    for (var _iterator14 = oldDirective.args[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n      var arg = _step14.value;\n\n      if (!newArgMap[arg.name]) {\n        removedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError14 = true;\n    _iteratorError14 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n        _iterator14.return();\n      }\n    } finally {\n      if (_didIteratorError14) {\n        throw _iteratorError14;\n      }\n    }\n  }\n\n  return removedArgs;\n}\n\nexport function findRemovedDirectiveArgs(oldSchema, newSchema) {\n  var removedDirectiveArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion15 = true;\n  var _didIteratorError15 = false;\n  var _iteratorError15 = undefined;\n\n  try {\n    for (var _iterator15 = newSchema.getDirectives()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n      var newDirective = _step15.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion16 = true;\n      var _didIteratorError16 = false;\n      var _iteratorError16 = undefined;\n\n      try {\n        for (var _iterator16 = findRemovedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n          var arg = _step16.value;\n          removedDirectiveArgs.push({\n            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n            description: \"\".concat(arg.name, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError16 = true;\n        _iteratorError16 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion16 && _iterator16.return != null) {\n            _iterator16.return();\n          }\n        } finally {\n          if (_didIteratorError16) {\n            throw _iteratorError16;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError15 = true;\n    _iteratorError15 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion15 && _iterator15.return != null) {\n        _iterator15.return();\n      }\n    } finally {\n      if (_didIteratorError15) {\n        throw _iteratorError15;\n      }\n    }\n  }\n\n  return removedDirectiveArgs;\n}\n\nfunction findAddedArgsForDirective(oldDirective, newDirective) {\n  var addedArgs = [];\n  var oldArgMap = getArgumentMapForDirective(oldDirective);\n  var _iteratorNormalCompletion17 = true;\n  var _didIteratorError17 = false;\n  var _iteratorError17 = undefined;\n\n  try {\n    for (var _iterator17 = newDirective.args[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n      var arg = _step17.value;\n\n      if (!oldArgMap[arg.name]) {\n        addedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError17 = true;\n    _iteratorError17 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion17 && _iterator17.return != null) {\n        _iterator17.return();\n      }\n    } finally {\n      if (_didIteratorError17) {\n        throw _iteratorError17;\n      }\n    }\n  }\n\n  return addedArgs;\n}\n\nexport function findAddedNonNullDirectiveArgs(oldSchema, newSchema) {\n  var addedNonNullableArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion18 = true;\n  var _didIteratorError18 = false;\n  var _iteratorError18 = undefined;\n\n  try {\n    for (var _iterator18 = newSchema.getDirectives()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n      var newDirective = _step18.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion19 = true;\n      var _didIteratorError19 = false;\n      var _iteratorError19 = undefined;\n\n      try {\n        for (var _iterator19 = findAddedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n          var arg = _step19.value;\n\n          if (isRequiredArgument(arg)) {\n            addedNonNullableArgs.push({\n              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n              description: \"A required arg \".concat(arg.name, \" on directive \") + \"\".concat(newDirective.name, \" was added\")\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError19 = true;\n        _iteratorError19 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {\n            _iterator19.return();\n          }\n        } finally {\n          if (_didIteratorError19) {\n            throw _iteratorError19;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError18 = true;\n    _iteratorError18 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion18 && _iterator18.return != null) {\n        _iterator18.return();\n      }\n    } finally {\n      if (_didIteratorError18) {\n        throw _iteratorError18;\n      }\n    }\n  }\n\n  return addedNonNullableArgs;\n}\nexport function findRemovedLocationsForDirective(oldDirective, newDirective) {\n  var removedLocations = [];\n  var newLocationSet = new Set(newDirective.locations);\n  var _iteratorNormalCompletion20 = true;\n  var _didIteratorError20 = false;\n  var _iteratorError20 = undefined;\n\n  try {\n    for (var _iterator20 = oldDirective.locations[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n      var oldLocation = _step20.value;\n\n      if (!newLocationSet.has(oldLocation)) {\n        removedLocations.push(oldLocation);\n      }\n    }\n  } catch (err) {\n    _didIteratorError20 = true;\n    _iteratorError20 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion20 && _iterator20.return != null) {\n        _iterator20.return();\n      }\n    } finally {\n      if (_didIteratorError20) {\n        throw _iteratorError20;\n      }\n    }\n  }\n\n  return removedLocations;\n}\nexport function findRemovedDirectiveLocations(oldSchema, newSchema) {\n  var removedLocations = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion21 = true;\n  var _didIteratorError21 = false;\n  var _iteratorError21 = undefined;\n\n  try {\n    for (var _iterator21 = newSchema.getDirectives()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n      var newDirective = _step21.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion22 = true;\n      var _didIteratorError22 = false;\n      var _iteratorError22 = undefined;\n\n      try {\n        for (var _iterator22 = findRemovedLocationsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\n          var location = _step22.value;\n          removedLocations.push({\n            type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n            description: \"\".concat(location, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError22 = true;\n        _iteratorError22 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion22 && _iterator22.return != null) {\n            _iterator22.return();\n          }\n        } finally {\n          if (_didIteratorError22) {\n            throw _iteratorError22;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError21 = true;\n    _iteratorError21 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion21 && _iterator21.return != null) {\n        _iterator21.return();\n      }\n    } finally {\n      if (_didIteratorError21) {\n        throw _iteratorError21;\n      }\n    }\n  }\n\n  return removedLocations;\n}\n\nfunction getDirectiveMapForSchema(schema) {\n  return keyMap(schema.getDirectives(), function (dir) {\n    return dir.name;\n  });\n}\n\nfunction getArgumentMapForDirective(directive) {\n  return keyMap(directive.args, function (arg) {\n    return arg.name;\n  });\n}","map":{"version":3,"names":["isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNonNullType","isListType","isNamedType","isRequiredArgument","isRequiredInputField","keyMap","BreakingChangeType","FIELD_CHANGED_KIND","FIELD_REMOVED","TYPE_CHANGED_KIND","TYPE_REMOVED","TYPE_REMOVED_FROM_UNION","VALUE_REMOVED_FROM_ENUM","ARG_REMOVED","ARG_CHANGED_KIND","REQUIRED_ARG_ADDED","REQUIRED_INPUT_FIELD_ADDED","INTERFACE_REMOVED_FROM_OBJECT","DIRECTIVE_REMOVED","DIRECTIVE_ARG_REMOVED","DIRECTIVE_LOCATION_REMOVED","REQUIRED_DIRECTIVE_ARG_ADDED","DangerousChangeType","ARG_DEFAULT_VALUE_CHANGE","VALUE_ADDED_TO_ENUM","INTERFACE_ADDED_TO_OBJECT","TYPE_ADDED_TO_UNION","OPTIONAL_INPUT_FIELD_ADDED","OPTIONAL_ARG_ADDED","findBreakingChanges","oldSchema","newSchema","findRemovedTypes","concat","findTypesThatChangedKind","findFieldsThatChangedTypeOnObjectOrInterfaceTypes","findFieldsThatChangedTypeOnInputObjectTypes","breakingChanges","findTypesRemovedFromUnions","findValuesRemovedFromEnums","findArgChanges","findInterfacesRemovedFromObjectTypes","findRemovedDirectives","findRemovedDirectiveArgs","findAddedNonNullDirectiveArgs","findRemovedDirectiveLocations","findDangerousChanges","dangerousChanges","findValuesAddedToEnums","findInterfacesAddedToObjectTypes","findTypesAddedToUnions","oldTypeMap","getTypeMap","newTypeMap","_arr","Object","keys","_i","length","typeName","push","type","description","_arr2","_i2","oldType","newType","constructor","typeKindName","_arr3","_i3","oldTypeFields","getFields","newTypeFields","_arr4","_i4","fieldName","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_loop","oldArgDef","_step","value","newArgs","args","newArgDef","find","arg","name","isSafe","isChangeSafeForInputObjectFieldOrFieldArg","toString","defaultValue","_iterator","Symbol","iterator","next","done","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_loop2","_step2","oldArgs","argName","_iterator2","TypeError","_arr5","_i5","oldTypeFieldsDef","newTypeFieldsDef","_arr6","_i6","oldFieldType","newFieldType","isChangeSafeForObjectOrInterfaceField","oldFieldTypeString","newFieldTypeString","_arr7","_i7","_arr8","_i8","_arr9","_i9","_fieldName","ofType","typesRemovedFromUnion","_arr10","_i10","typeNamesInNewUnion","create","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","getTypes","_step3","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_type","typesAddedToUnion","_arr11","_i11","typeNamesInOldUnion","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","_type2","valuesRemovedFromEnums","_arr12","_i12","valuesInNewEnum","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","getValues","_step7","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_iterator8","_step8","_value","valuesAddedToEnums","_arr13","_i13","valuesInOldEnum","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_iterator9","_step9","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_iterator10","_step10","_value2","_arr14","_i14","oldInterfaces","getInterfaces","newInterfaces","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_loop3","oldInterface","_step11","some","int","_iterator11","interfacesAddedToObjectTypes","_arr15","_i15","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_loop4","newInterface","_step12","_iterator12","removedDirectives","newSchemaDirectiveMap","getDirectiveMapForSchema","_iteratorNormalCompletion13","_didIteratorError13","_iteratorError13","_iterator13","getDirectives","_step13","directive","findRemovedArgsForDirective","oldDirective","newDirective","removedArgs","newArgMap","getArgumentMapForDirective","_iteratorNormalCompletion14","_didIteratorError14","_iteratorError14","_iterator14","_step14","removedDirectiveArgs","oldSchemaDirectiveMap","_iteratorNormalCompletion15","_didIteratorError15","_iteratorError15","_iterator15","_step15","_iteratorNormalCompletion16","_didIteratorError16","_iteratorError16","_iterator16","_step16","findAddedArgsForDirective","addedArgs","oldArgMap","_iteratorNormalCompletion17","_didIteratorError17","_iteratorError17","_iterator17","_step17","addedNonNullableArgs","_iteratorNormalCompletion18","_didIteratorError18","_iteratorError18","_iterator18","_step18","_iteratorNormalCompletion19","_didIteratorError19","_iteratorError19","_iterator19","_step19","findRemovedLocationsForDirective","removedLocations","newLocationSet","Set","locations","_iteratorNormalCompletion20","_didIteratorError20","_iteratorError20","_iterator20","_step20","oldLocation","has","_iteratorNormalCompletion21","_didIteratorError21","_iteratorError21","_iterator21","_step21","_iteratorNormalCompletion22","_didIteratorError22","_iteratorError22","_iterator22","_step22","location","schema","dir"],"sources":["/home/xl355/341/aws-bookstore-demo-app/assets/node_modules/@aws-amplify/api/node_modules/graphql/utilities/findBreakingChanges.mjs"],"sourcesContent":["/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType, isRequiredArgument, isRequiredInputField } from '../type/definition';\nimport keyMap from '../jsutils/keyMap';\nexport var BreakingChangeType = {\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  REQUIRED_ARG_ADDED: 'REQUIRED_ARG_ADDED',\n  REQUIRED_INPUT_FIELD_ADDED: 'REQUIRED_INPUT_FIELD_ADDED',\n  INTERFACE_REMOVED_FROM_OBJECT: 'INTERFACE_REMOVED_FROM_OBJECT',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED',\n  REQUIRED_DIRECTIVE_ARG_ADDED: 'REQUIRED_DIRECTIVE_ARG_ADDED'\n};\nexport var DangerousChangeType = {\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE',\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  INTERFACE_ADDED_TO_OBJECT: 'INTERFACE_ADDED_TO_OBJECT',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  OPTIONAL_INPUT_FIELD_ADDED: 'OPTIONAL_INPUT_FIELD_ADDED',\n  OPTIONAL_ARG_ADDED: 'OPTIONAL_ARG_ADDED'\n};\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  return findRemovedTypes(oldSchema, newSchema).concat(findTypesThatChangedKind(oldSchema, newSchema), findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).breakingChanges, findTypesRemovedFromUnions(oldSchema, newSchema), findValuesRemovedFromEnums(oldSchema, newSchema), findArgChanges(oldSchema, newSchema).breakingChanges, findInterfacesRemovedFromObjectTypes(oldSchema, newSchema), findRemovedDirectives(oldSchema, newSchema), findRemovedDirectiveArgs(oldSchema, newSchema), findAddedNonNullDirectiveArgs(oldSchema, newSchema), findRemovedDirectiveLocations(oldSchema, newSchema));\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  return findArgChanges(oldSchema, newSchema).dangerousChanges.concat(findValuesAddedToEnums(oldSchema, newSchema), findInterfacesAddedToObjectTypes(oldSchema, newSchema), findTypesAddedToUnions(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).dangerousChanges);\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing an entire type.\n */\n\nexport function findRemovedTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr = Object.keys(oldTypeMap);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var typeName = _arr[_i];\n\n    if (!newTypeMap[typeName]) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED,\n        description: \"\".concat(typeName, \" was removed.\")\n      });\n    }\n  }\n\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to changing the type of a type.\n */\n\nexport function findTypesThatChangedKind(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr2 = Object.keys(oldTypeMap);\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var typeName = _arr2[_i2];\n\n    if (!newTypeMap[typeName]) {\n      continue;\n    }\n\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (oldType.constructor !== newType.constructor) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: \"\".concat(typeName, \" changed from \") + \"\".concat(typeKindName(oldType), \" to \").concat(typeKindName(newType), \".\")\n      });\n    }\n  }\n\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any\n * breaking or dangerous changes in the newSchema related to arguments\n * (such as removal or change of type of an argument, or a change in an\n * argument's default value).\n */\n\nexport function findArgChanges(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  var _arr3 = Object.keys(oldTypeMap);\n\n  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n    var typeName = _arr3[_i3];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n\n    var oldTypeFields = oldType.getFields();\n    var newTypeFields = newType.getFields();\n\n    var _arr4 = Object.keys(oldTypeFields);\n\n    for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n      var fieldName = _arr4[_i4];\n\n      if (!newTypeFields[fieldName]) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var oldArgDef = _step.value;\n          var newArgs = newTypeFields[fieldName].args;\n          var newArgDef = newArgs.find(function (arg) {\n            return arg.name === oldArgDef.name;\n          }); // Arg not present\n\n          if (!newArgDef) {\n            breakingChanges.push({\n              type: BreakingChangeType.ARG_REMOVED,\n              description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" was removed\")\n            });\n          } else {\n            var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);\n\n            if (!isSafe) {\n              breakingChanges.push({\n                type: BreakingChangeType.ARG_CHANGED_KIND,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed type from \") + \"\".concat(oldArgDef.type.toString(), \" to \").concat(newArgDef.type.toString())\n              });\n            } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {\n              dangerousChanges.push({\n                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed defaultValue\")\n              });\n            }\n          }\n        };\n\n        for (var _iterator = oldTypeFields[fieldName].args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          _loop();\n        } // Check if arg was added to the field\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        var _loop2 = function _loop2() {\n          var newArgDef = _step2.value;\n          var oldArgs = oldTypeFields[fieldName].args;\n          var oldArgDef = oldArgs.find(function (arg) {\n            return arg.name === newArgDef.name;\n          });\n\n          if (!oldArgDef) {\n            var argName = newArgDef.name;\n\n            if (isRequiredArgument(newArgDef)) {\n              breakingChanges.push({\n                type: BreakingChangeType.REQUIRED_ARG_ADDED,\n                description: \"A required arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            } else {\n              dangerousChanges.push({\n                type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n                description: \"An optional arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            }\n          }\n        };\n\n        for (var _iterator2 = newTypeFields[fieldName].args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          _loop2();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n\n  throw new TypeError('Unknown type ' + type.constructor.name);\n}\n\nexport function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr5 = Object.keys(oldTypeMap);\n\n  for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n    var typeName = _arr5[_i5];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n\n    var _arr6 = Object.keys(oldTypeFieldsDef);\n\n    for (var _i6 = 0; _i6 < _arr6.length; _i6++) {\n      var fieldName = _arr6[_i6];\n\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForObjectOrInterfaceField(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    }\n  }\n\n  return breakingChanges;\n}\nexport function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  var _arr7 = Object.keys(oldTypeMap);\n\n  for (var _i7 = 0; _i7 < _arr7.length; _i7++) {\n    var typeName = _arr7[_i7];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isInputObjectType(oldType) || !isInputObjectType(newType)) {\n      continue;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n\n    var _arr8 = Object.keys(oldTypeFieldsDef);\n\n    for (var _i8 = 0; _i8 < _arr8.length; _i8++) {\n      var fieldName = _arr8[_i8];\n\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    } // Check if a field was added to the input object type\n\n\n    var _arr9 = Object.keys(newTypeFieldsDef);\n\n    for (var _i9 = 0; _i9 < _arr9.length; _i9++) {\n      var _fieldName = _arr9[_i9];\n\n      if (!(_fieldName in oldTypeFieldsDef)) {\n        if (isRequiredInputField(newTypeFieldsDef[_fieldName])) {\n          breakingChanges.push({\n            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n            description: \"A required field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        } else {\n          dangerousChanges.push({\n            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n            description: \"An optional field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        }\n      }\n    }\n  }\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isNamedType(oldType)) {\n    return (// if they're both named types, see if their names are equivalent\n      isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isListType(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return false;\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isNamedType(oldType)) {\n    // if they're both named types, see if their names are equivalent\n    return isNamedType(newType) && oldType.name === newType.name;\n  } else if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  } else if (isNonNullType(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  }\n\n  return false;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing types from a union type.\n */\n\n\nexport function findTypesRemovedFromUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesRemovedFromUnion = [];\n\n  var _arr10 = Object.keys(oldTypeMap);\n\n  for (var _i10 = 0; _i10 < _arr10.length; _i10++) {\n    var typeName = _arr10[_i10];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      continue;\n    }\n\n    var typeNamesInNewUnion = Object.create(null);\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = newType.getTypes()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var type = _step3.value;\n        typeNamesInNewUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = oldType.getTypes()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _type = _step4.value;\n\n        if (!typeNamesInNewUnion[_type.name]) {\n          typesRemovedFromUnion.push({\n            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n            description: \"\".concat(_type.name, \" was removed from union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  }\n\n  return typesRemovedFromUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding types to a union type.\n */\n\nexport function findTypesAddedToUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesAddedToUnion = [];\n\n  var _arr11 = Object.keys(newTypeMap);\n\n  for (var _i11 = 0; _i11 < _arr11.length; _i11++) {\n    var typeName = _arr11[_i11];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      continue;\n    }\n\n    var typeNamesInOldUnion = Object.create(null);\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = oldType.getTypes()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var type = _step5.value;\n        typeNamesInOldUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = newType.getTypes()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var _type2 = _step6.value;\n\n        if (!typeNamesInOldUnion[_type2.name]) {\n          typesAddedToUnion.push({\n            type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n            description: \"\".concat(_type2.name, \" was added to union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  }\n\n  return typesAddedToUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing values from an enum type.\n */\n\nexport function findValuesRemovedFromEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesRemovedFromEnums = [];\n\n  var _arr12 = Object.keys(oldTypeMap);\n\n  for (var _i12 = 0; _i12 < _arr12.length; _i12++) {\n    var typeName = _arr12[_i12];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      continue;\n    }\n\n    var valuesInNewEnum = Object.create(null);\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n\n    try {\n      for (var _iterator7 = newType.getValues()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n        var value = _step7.value;\n        valuesInNewEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError7 = true;\n      _iteratorError7 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n          _iterator7.return();\n        }\n      } finally {\n        if (_didIteratorError7) {\n          throw _iteratorError7;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      for (var _iterator8 = oldType.getValues()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _value = _step8.value;\n\n        if (!valuesInNewEnum[_value.name]) {\n          valuesRemovedFromEnums.push({\n            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n            description: \"\".concat(_value.name, \" was removed from enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n  }\n\n  return valuesRemovedFromEnums;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding values to an enum type.\n */\n\nexport function findValuesAddedToEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesAddedToEnums = [];\n\n  var _arr13 = Object.keys(oldTypeMap);\n\n  for (var _i13 = 0; _i13 < _arr13.length; _i13++) {\n    var typeName = _arr13[_i13];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      continue;\n    }\n\n    var valuesInOldEnum = Object.create(null);\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      for (var _iterator9 = oldType.getValues()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        var value = _step9.value;\n        valuesInOldEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion10 = true;\n    var _didIteratorError10 = false;\n    var _iteratorError10 = undefined;\n\n    try {\n      for (var _iterator10 = newType.getValues()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n        var _value2 = _step10.value;\n\n        if (!valuesInOldEnum[_value2.name]) {\n          valuesAddedToEnums.push({\n            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n            description: \"\".concat(_value2.name, \" was added to enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError10 = true;\n      _iteratorError10 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n          _iterator10.return();\n        }\n      } finally {\n        if (_didIteratorError10) {\n          throw _iteratorError10;\n        }\n      }\n    }\n  }\n\n  return valuesAddedToEnums;\n}\nexport function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr14 = Object.keys(oldTypeMap);\n\n  for (var _i14 = 0; _i14 < _arr14.length; _i14++) {\n    var typeName = _arr14[_i14];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      continue;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion11 = true;\n    var _didIteratorError11 = false;\n    var _iteratorError11 = undefined;\n\n    try {\n      var _loop3 = function _loop3() {\n        var oldInterface = _step11.value;\n\n        if (!newInterfaces.some(function (int) {\n          return int.name === oldInterface.name;\n        })) {\n          breakingChanges.push({\n            type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,\n            description: \"\".concat(typeName, \" no longer implements interface \") + \"\".concat(oldInterface.name, \".\")\n          });\n        }\n      };\n\n      for (var _iterator11 = oldInterfaces[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n        _loop3();\n      }\n    } catch (err) {\n      _didIteratorError11 = true;\n      _iteratorError11 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n          _iterator11.return();\n        }\n      } finally {\n        if (_didIteratorError11) {\n          throw _iteratorError11;\n        }\n      }\n    }\n  }\n\n  return breakingChanges;\n}\nexport function findInterfacesAddedToObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var interfacesAddedToObjectTypes = [];\n\n  var _arr15 = Object.keys(newTypeMap);\n\n  for (var _i15 = 0; _i15 < _arr15.length; _i15++) {\n    var typeName = _arr15[_i15];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      continue;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion12 = true;\n    var _didIteratorError12 = false;\n    var _iteratorError12 = undefined;\n\n    try {\n      var _loop4 = function _loop4() {\n        var newInterface = _step12.value;\n\n        if (!oldInterfaces.some(function (int) {\n          return int.name === newInterface.name;\n        })) {\n          interfacesAddedToObjectTypes.push({\n            type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,\n            description: \"\".concat(newInterface.name, \" added to interfaces implemented \") + \"by \".concat(typeName, \".\")\n          });\n        }\n      };\n\n      for (var _iterator12 = newInterfaces[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n        _loop4();\n      }\n    } catch (err) {\n      _didIteratorError12 = true;\n      _iteratorError12 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n          _iterator12.return();\n        }\n      } finally {\n        if (_didIteratorError12) {\n          throw _iteratorError12;\n        }\n      }\n    }\n  }\n\n  return interfacesAddedToObjectTypes;\n}\nexport function findRemovedDirectives(oldSchema, newSchema) {\n  var removedDirectives = [];\n  var newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n\n  try {\n    for (var _iterator13 = oldSchema.getDirectives()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var directive = _step13.value;\n\n      if (!newSchemaDirectiveMap[directive.name]) {\n        removedDirectives.push({\n          type: BreakingChangeType.DIRECTIVE_REMOVED,\n          description: \"\".concat(directive.name, \" was removed\")\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n\n  return removedDirectives;\n}\n\nfunction findRemovedArgsForDirective(oldDirective, newDirective) {\n  var removedArgs = [];\n  var newArgMap = getArgumentMapForDirective(newDirective);\n  var _iteratorNormalCompletion14 = true;\n  var _didIteratorError14 = false;\n  var _iteratorError14 = undefined;\n\n  try {\n    for (var _iterator14 = oldDirective.args[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n      var arg = _step14.value;\n\n      if (!newArgMap[arg.name]) {\n        removedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError14 = true;\n    _iteratorError14 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n        _iterator14.return();\n      }\n    } finally {\n      if (_didIteratorError14) {\n        throw _iteratorError14;\n      }\n    }\n  }\n\n  return removedArgs;\n}\n\nexport function findRemovedDirectiveArgs(oldSchema, newSchema) {\n  var removedDirectiveArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion15 = true;\n  var _didIteratorError15 = false;\n  var _iteratorError15 = undefined;\n\n  try {\n    for (var _iterator15 = newSchema.getDirectives()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n      var newDirective = _step15.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion16 = true;\n      var _didIteratorError16 = false;\n      var _iteratorError16 = undefined;\n\n      try {\n        for (var _iterator16 = findRemovedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n          var arg = _step16.value;\n          removedDirectiveArgs.push({\n            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n            description: \"\".concat(arg.name, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError16 = true;\n        _iteratorError16 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion16 && _iterator16.return != null) {\n            _iterator16.return();\n          }\n        } finally {\n          if (_didIteratorError16) {\n            throw _iteratorError16;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError15 = true;\n    _iteratorError15 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion15 && _iterator15.return != null) {\n        _iterator15.return();\n      }\n    } finally {\n      if (_didIteratorError15) {\n        throw _iteratorError15;\n      }\n    }\n  }\n\n  return removedDirectiveArgs;\n}\n\nfunction findAddedArgsForDirective(oldDirective, newDirective) {\n  var addedArgs = [];\n  var oldArgMap = getArgumentMapForDirective(oldDirective);\n  var _iteratorNormalCompletion17 = true;\n  var _didIteratorError17 = false;\n  var _iteratorError17 = undefined;\n\n  try {\n    for (var _iterator17 = newDirective.args[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n      var arg = _step17.value;\n\n      if (!oldArgMap[arg.name]) {\n        addedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError17 = true;\n    _iteratorError17 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion17 && _iterator17.return != null) {\n        _iterator17.return();\n      }\n    } finally {\n      if (_didIteratorError17) {\n        throw _iteratorError17;\n      }\n    }\n  }\n\n  return addedArgs;\n}\n\nexport function findAddedNonNullDirectiveArgs(oldSchema, newSchema) {\n  var addedNonNullableArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion18 = true;\n  var _didIteratorError18 = false;\n  var _iteratorError18 = undefined;\n\n  try {\n    for (var _iterator18 = newSchema.getDirectives()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n      var newDirective = _step18.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion19 = true;\n      var _didIteratorError19 = false;\n      var _iteratorError19 = undefined;\n\n      try {\n        for (var _iterator19 = findAddedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n          var arg = _step19.value;\n\n          if (isRequiredArgument(arg)) {\n            addedNonNullableArgs.push({\n              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n              description: \"A required arg \".concat(arg.name, \" on directive \") + \"\".concat(newDirective.name, \" was added\")\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError19 = true;\n        _iteratorError19 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {\n            _iterator19.return();\n          }\n        } finally {\n          if (_didIteratorError19) {\n            throw _iteratorError19;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError18 = true;\n    _iteratorError18 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion18 && _iterator18.return != null) {\n        _iterator18.return();\n      }\n    } finally {\n      if (_didIteratorError18) {\n        throw _iteratorError18;\n      }\n    }\n  }\n\n  return addedNonNullableArgs;\n}\nexport function findRemovedLocationsForDirective(oldDirective, newDirective) {\n  var removedLocations = [];\n  var newLocationSet = new Set(newDirective.locations);\n  var _iteratorNormalCompletion20 = true;\n  var _didIteratorError20 = false;\n  var _iteratorError20 = undefined;\n\n  try {\n    for (var _iterator20 = oldDirective.locations[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n      var oldLocation = _step20.value;\n\n      if (!newLocationSet.has(oldLocation)) {\n        removedLocations.push(oldLocation);\n      }\n    }\n  } catch (err) {\n    _didIteratorError20 = true;\n    _iteratorError20 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion20 && _iterator20.return != null) {\n        _iterator20.return();\n      }\n    } finally {\n      if (_didIteratorError20) {\n        throw _iteratorError20;\n      }\n    }\n  }\n\n  return removedLocations;\n}\nexport function findRemovedDirectiveLocations(oldSchema, newSchema) {\n  var removedLocations = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion21 = true;\n  var _didIteratorError21 = false;\n  var _iteratorError21 = undefined;\n\n  try {\n    for (var _iterator21 = newSchema.getDirectives()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n      var newDirective = _step21.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion22 = true;\n      var _didIteratorError22 = false;\n      var _iteratorError22 = undefined;\n\n      try {\n        for (var _iterator22 = findRemovedLocationsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\n          var location = _step22.value;\n          removedLocations.push({\n            type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n            description: \"\".concat(location, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError22 = true;\n        _iteratorError22 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion22 && _iterator22.return != null) {\n            _iterator22.return();\n          }\n        } finally {\n          if (_didIteratorError22) {\n            throw _iteratorError22;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError21 = true;\n    _iteratorError21 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion21 && _iterator21.return != null) {\n        _iterator21.return();\n      }\n    } finally {\n      if (_didIteratorError21) {\n        throw _iteratorError21;\n      }\n    }\n  }\n\n  return removedLocations;\n}\n\nfunction getDirectiveMapForSchema(schema) {\n  return keyMap(schema.getDirectives(), function (dir) {\n    return dir.name;\n  });\n}\n\nfunction getArgumentMapForDirective(directive) {\n  return keyMap(directive.args, function (arg) {\n    return arg.name;\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}