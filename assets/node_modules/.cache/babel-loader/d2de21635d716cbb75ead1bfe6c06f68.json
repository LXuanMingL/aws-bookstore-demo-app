{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isInputType, isOutputType, isRequiredArgument } from './definition';\nimport { isDirective } from './directives';\nimport { isIntrospectionType } from './introspection';\nimport { isSchema } from './schema';\nimport inspect from '../jsutils/inspect';\nimport find from '../jsutils/find';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isValidNameError } from '../utilities/assertValidName';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  !isSchema(schema) ? invariant(0, \"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\")) : void 0; // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext = /*#__PURE__*/function () {\n  function SchemaValidationContext(schema) {\n    _defineProperty(this, \"_errors\", void 0);\n\n    _defineProperty(this, \"schema\", void 0);\n\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = (Array.isArray(nodes) ? nodes : [nodes]).filter(Boolean);\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError(\"Query root type must be provided.\", schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), getOperationTypeNode(schema, queryType, 'query'));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\n\nfunction getOperationTypeNode(schema, type, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = operationNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var node = _step.value;\n\n      if (node.operation === operation) {\n        return node.type;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return type.astNode;\n}\n\nfunction validateDirectives(context) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = context.schema.getDirectives()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var directive = _step2.value; // Ensure all directives are in fact GraphQL directives.\n\n      if (!isDirective(directive)) {\n        context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive && directive.astNode);\n        continue;\n      } // Ensure they are named correctly.\n\n\n      validateName(context, directive); // TODO: Ensure proper locations.\n      // Ensure the arguments are valid.\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = directive.args[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var arg = _step3.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per directive.\n\n          if (argNames[argName]) {\n            context.reportError(\"Argument @\".concat(directive.name, \"(\").concat(argName, \":) can only be defined once.\"), getAllDirectiveArgNodes(directive, argName));\n            continue;\n          }\n\n          argNames[argName] = true; // Ensure the type is an input type.\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(argName, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), getDirectiveArgTypeNode(directive, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  } // Ensure names are valid, however introspection types opt out.\n\n\n  var error = isValidNameError(node.name, node.astNode || undefined);\n\n  if (error) {\n    context.addError(error);\n  }\n}\n\nfunction validateTypes(context) {\n  var typeMap = context.schema.getTypeMap();\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = objectValues(typeMap)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var type = _step4.value; // Ensure all provided types are in fact GraphQL type.\n\n      if (!isNamedType(type)) {\n        context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type && type.astNode);\n        continue;\n      } // Ensure it is named correctly (excluding introspection types).\n\n\n      if (!isIntrospectionType(type)) {\n        validateName(context, type);\n      }\n\n      if (isObjectType(type)) {\n        // Ensure fields are valid\n        validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n        validateObjectInterfaces(context, type);\n      } else if (isInterfaceType(type)) {\n        // Ensure fields are valid.\n        validateFields(context, type);\n      } else if (isUnionType(type)) {\n        // Ensure Unions include valid member types.\n        validateUnionMembers(context, type);\n      } else if (isEnumType(type)) {\n        // Ensure Enums have valid values.\n        validateEnumValues(context, type);\n      } else if (isInputObjectType(type)) {\n        // Ensure Input Object fields are valid.\n        validateInputFields(context, type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = fields[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var field = _step5.value; // Ensure they are named correctly.\n\n      validateName(context, field); // Ensure they were defined at most once.\n\n      var fieldNodes = getAllFieldNodes(type, field.name);\n\n      if (fieldNodes.length > 1) {\n        context.reportError(\"Field \".concat(type.name, \".\").concat(field.name, \" can only be defined once.\"), fieldNodes);\n        continue;\n      } // Ensure the type is an output type\n\n\n      if (!isOutputType(field.type)) {\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), getFieldTypeNode(type, field.name));\n      } // Ensure the arguments are valid\n\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = field.args[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var arg = _step6.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per field.\n\n          if (argNames[argName]) {\n            context.reportError(\"Field argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) can only \") + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));\n          }\n\n          argNames[argName] = true; // Ensure the type is an input type\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), getFieldArgTypeNode(type, field.name, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\n\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion7 = true;\n  var _didIteratorError7 = false;\n  var _iteratorError7 = undefined;\n\n  try {\n    for (var _iterator7 = object.getInterfaces()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n      var iface = _step7.value;\n\n      if (!isInterfaceType(iface)) {\n        context.reportError(\"Type \".concat(inspect(object), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getImplementsInterfaceNode(object, iface));\n        continue;\n      }\n\n      if (implementedTypeNames[iface.name]) {\n        context.reportError(\"Type \".concat(object.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(object, iface));\n        continue;\n      }\n\n      implementedTypeNames[iface.name] = true;\n      validateObjectImplementsInterface(context, object, iface);\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n        _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n}\n\nfunction validateObjectImplementsInterface(context, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.\n\n  var _arr = Object.keys(ifaceFieldMap);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var fieldName = _arr[_i];\n    var objectField = objectFieldMap[fieldName];\n    var ifaceField = ifaceFieldMap[fieldName]; // Assert interface field exists on object.\n\n    if (!objectField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \") + \"\".concat(object.name, \" does not provide it.\"), [getFieldNode(iface, fieldName)].concat(getAllNodes(object)));\n      continue;\n    } // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(object.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(objectField.type), \".\"), [getFieldTypeNode(iface, fieldName), getFieldTypeNode(object, fieldName)]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      var _loop = function _loop() {\n        var ifaceArg = _step8.value;\n        var argName = ifaceArg.name;\n        var objectArg = find(objectField.args, function (arg) {\n          return arg.name === argName;\n        }); // Assert interface field arg exists on object field.\n\n        if (!objectArg) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expected but \".concat(object.name, \".\").concat(fieldName, \" does not provide it.\"), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]);\n          return \"continue\";\n        } // Assert interface field arg type matches object field arg type.\n        // (invariant)\n        // TODO: change to contravariant?\n\n\n        if (!isEqualType(ifaceArg.type, objectArg.type)) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(object.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(objectArg.type), \".\"), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);\n        } // TODO: validate default values?\n\n      };\n\n      for (var _iterator8 = ifaceField.args[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      } // Assert additional arguments must not be required.\n\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      var _loop2 = function _loop2() {\n        var objectArg = _step9.value;\n        var argName = objectArg.name;\n        var ifaceArg = find(ifaceField.args, function (arg) {\n          return arg.name === argName;\n        });\n\n        if (!ifaceArg && isRequiredArgument(objectArg)) {\n          context.reportError(\"Object field \".concat(object.name, \".\").concat(fieldName, \" includes required \") + \"argument \".concat(argName, \" that is missing from the Interface field \") + \"\".concat(iface.name, \".\").concat(fieldName, \".\"), [getFieldArgNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);\n        }\n      };\n\n      for (var _iterator9 = objectField.args[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        _loop2();\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion10 = true;\n  var _didIteratorError10 = false;\n  var _iteratorError10 = undefined;\n\n  try {\n    for (var _iterator10 = memberTypes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n      var memberType = _step10.value;\n\n      if (includedTypeNames[memberType.name]) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include type \") + \"\".concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n        continue;\n      }\n\n      includedTypeNames[memberType.name] = true;\n\n      if (!isObjectType(memberType)) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n      }\n    }\n  } catch (err) {\n    _didIteratorError10 = true;\n    _iteratorError10 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n        _iterator10.return();\n      }\n    } finally {\n      if (_didIteratorError10) {\n        throw _iteratorError10;\n      }\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  var _iteratorNormalCompletion11 = true;\n  var _didIteratorError11 = false;\n  var _iteratorError11 = undefined;\n\n  try {\n    for (var _iterator11 = enumValues[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n      var enumValue = _step11.value;\n      var valueName = enumValue.name; // Ensure no duplicates.\n\n      var allNodes = getEnumValueNodes(enumType, valueName);\n\n      if (allNodes && allNodes.length > 1) {\n        context.reportError(\"Enum type \".concat(enumType.name, \" can include value \").concat(valueName, \" only once.\"), allNodes);\n      } // Ensure valid name.\n\n\n      validateName(context, enumValue);\n\n      if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n        context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n      }\n    }\n  } catch (err) {\n    _didIteratorError11 = true;\n    _iteratorError11 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n        _iterator11.return();\n      }\n    } finally {\n      if (_didIteratorError11) {\n        throw _iteratorError11;\n      }\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  var _iteratorNormalCompletion12 = true;\n  var _didIteratorError12 = false;\n  var _iteratorError12 = undefined;\n\n  try {\n    for (var _iterator12 = fields[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n      var field = _step12.value; // Ensure they are named correctly.\n\n      validateName(context, field); // TODO: Ensure they are unique per field.\n      // Ensure the type is an input type\n\n      if (!isInputType(field.type)) {\n        context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError12 = true;\n    _iteratorError12 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n        _iterator12.return();\n      }\n    } finally {\n      if (_didIteratorError12) {\n        throw _iteratorError12;\n      }\n    }\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  var result = [];\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n\n  try {\n    for (var _iterator13 = getAllNodes(object)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var astNode = _step13.value;\n\n      if (astNode) {\n        var subNodes = getter(astNode);\n\n        if (subNodes) {\n          result = result.concat(subNodes);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getImplementsInterfaceNode(type, iface) {\n  return getAllImplementsInterfaceNodes(type, iface)[0];\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getFieldNode(type, fieldName) {\n  return getAllFieldNodes(type, fieldName)[0];\n}\n\nfunction getAllFieldNodes(type, fieldName) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.fields;\n  }).filter(function (fieldNode) {\n    return fieldNode.name.value === fieldName;\n  });\n}\n\nfunction getFieldTypeNode(type, fieldName) {\n  var fieldNode = getFieldNode(type, fieldName);\n  return fieldNode && fieldNode.type;\n}\n\nfunction getFieldArgNode(type, fieldName, argName) {\n  return getAllFieldArgNodes(type, fieldName, argName)[0];\n}\n\nfunction getAllFieldArgNodes(type, fieldName, argName) {\n  var argNodes = [];\n  var fieldNode = getFieldNode(type, fieldName);\n\n  if (fieldNode && fieldNode.arguments) {\n    var _iteratorNormalCompletion14 = true;\n    var _didIteratorError14 = false;\n    var _iteratorError14 = undefined;\n\n    try {\n      for (var _iterator14 = fieldNode.arguments[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n        var node = _step14.value;\n\n        if (node.name.value === argName) {\n          argNodes.push(node);\n        }\n      }\n    } catch (err) {\n      _didIteratorError14 = true;\n      _iteratorError14 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n          _iterator14.return();\n        }\n      } finally {\n        if (_didIteratorError14) {\n          throw _iteratorError14;\n        }\n      }\n    }\n  }\n\n  return argNodes;\n}\n\nfunction getFieldArgTypeNode(type, fieldName, argName) {\n  var fieldArgNode = getFieldArgNode(type, fieldName, argName);\n  return fieldArgNode && fieldArgNode.type;\n}\n\nfunction getAllDirectiveArgNodes(directive, argName) {\n  return getAllSubNodes(directive, function (directiveNode) {\n    return directiveNode.arguments;\n  }).filter(function (argNode) {\n    return argNode.name.value === argName;\n  });\n}\n\nfunction getDirectiveArgTypeNode(directive, argName) {\n  var argNode = getAllDirectiveArgNodes(directive, argName)[0];\n  return argNode && argNode.type;\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n\nfunction getEnumValueNodes(enumType, valueName) {\n  return getAllSubNodes(enumType, function (enumNode) {\n    return enumNode.values;\n  }).filter(function (valueNode) {\n    return valueNode.name.value === valueName;\n  });\n}","map":{"version":3,"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNamedType","isInputType","isOutputType","isRequiredArgument","isDirective","isIntrospectionType","isSchema","inspect","find","invariant","objectValues","GraphQLError","isValidNameError","isEqualType","isTypeSubTypeOf","validateSchema","schema","concat","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","_errors","_proto","prototype","reportError","nodes","_nodes","Array","isArray","filter","Boolean","addError","push","queryType","getQueryType","astNode","getOperationTypeNode","mutationType","getMutationType","subscriptionType","getSubscriptionType","type","operation","operationNodes","getAllSubNodes","node","operationTypes","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","getDirectives","_step2","directive","validateName","argNames","create","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","args","_step3","arg","argName","name","getAllDirectiveArgNodes","getDirectiveArgTypeNode","__allowedLegacyNames","indexOf","typeMap","getTypeMap","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","validateFields","validateObjectInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","getAllNodes","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","field","fieldNodes","getAllFieldNodes","getFieldTypeNode","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","getAllFieldArgNodes","getFieldArgTypeNode","object","implementedTypeNames","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","getInterfaces","_step7","iface","getImplementsInterfaceNode","getAllImplementsInterfaceNodes","validateObjectImplementsInterface","objectFieldMap","ifaceFieldMap","_arr","keys","_i","fieldName","objectField","ifaceField","getFieldNode","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_loop","ifaceArg","_step8","objectArg","getFieldArgNode","_iterator8","_ret","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_loop2","_step9","_iterator9","union","memberTypes","getTypes","includedTypeNames","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_iterator10","_step10","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_iterator11","_step11","enumValue","valueName","allNodes","getEnumValueNodes","inputObj","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_iterator12","_step12","extensionASTNodes","getter","result","_iteratorNormalCompletion13","_didIteratorError13","_iteratorError13","_iterator13","_step13","subNodes","typeNode","interfaces","ifaceNode","fieldNode","argNodes","arguments","_iteratorNormalCompletion14","_didIteratorError14","_iteratorError14","_iterator14","_step14","fieldArgNode","directiveNode","argNode","typeName","unionNode","types","enumNode","values","valueNode"],"sources":["/home/xl355/341/aws-bookstore-demo-app/assets/node_modules/@aws-amplify/api/node_modules/graphql/type/validate.mjs"],"sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isInputType, isOutputType, isRequiredArgument } from './definition';\nimport { isDirective } from './directives';\nimport { isIntrospectionType } from './introspection';\nimport { isSchema } from './schema';\nimport inspect from '../jsutils/inspect';\nimport find from '../jsutils/find';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isValidNameError } from '../utilities/assertValidName';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  !isSchema(schema) ? invariant(0, \"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\")) : void 0; // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext =\n/*#__PURE__*/\nfunction () {\n  function SchemaValidationContext(schema) {\n    _defineProperty(this, \"_errors\", void 0);\n\n    _defineProperty(this, \"schema\", void 0);\n\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = (Array.isArray(nodes) ? nodes : [nodes]).filter(Boolean);\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError(\"Query root type must be provided.\", schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), getOperationTypeNode(schema, queryType, 'query'));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\n\nfunction getOperationTypeNode(schema, type, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = operationNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var node = _step.value;\n\n      if (node.operation === operation) {\n        return node.type;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return type.astNode;\n}\n\nfunction validateDirectives(context) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = context.schema.getDirectives()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var directive = _step2.value;\n\n      // Ensure all directives are in fact GraphQL directives.\n      if (!isDirective(directive)) {\n        context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive && directive.astNode);\n        continue;\n      } // Ensure they are named correctly.\n\n\n      validateName(context, directive); // TODO: Ensure proper locations.\n      // Ensure the arguments are valid.\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = directive.args[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var arg = _step3.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per directive.\n\n          if (argNames[argName]) {\n            context.reportError(\"Argument @\".concat(directive.name, \"(\").concat(argName, \":) can only be defined once.\"), getAllDirectiveArgNodes(directive, argName));\n            continue;\n          }\n\n          argNames[argName] = true; // Ensure the type is an input type.\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(argName, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), getDirectiveArgTypeNode(directive, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  } // Ensure names are valid, however introspection types opt out.\n\n\n  var error = isValidNameError(node.name, node.astNode || undefined);\n\n  if (error) {\n    context.addError(error);\n  }\n}\n\nfunction validateTypes(context) {\n  var typeMap = context.schema.getTypeMap();\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = objectValues(typeMap)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var type = _step4.value;\n\n      // Ensure all provided types are in fact GraphQL type.\n      if (!isNamedType(type)) {\n        context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type && type.astNode);\n        continue;\n      } // Ensure it is named correctly (excluding introspection types).\n\n\n      if (!isIntrospectionType(type)) {\n        validateName(context, type);\n      }\n\n      if (isObjectType(type)) {\n        // Ensure fields are valid\n        validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n        validateObjectInterfaces(context, type);\n      } else if (isInterfaceType(type)) {\n        // Ensure fields are valid.\n        validateFields(context, type);\n      } else if (isUnionType(type)) {\n        // Ensure Unions include valid member types.\n        validateUnionMembers(context, type);\n      } else if (isEnumType(type)) {\n        // Ensure Enums have valid values.\n        validateEnumValues(context, type);\n      } else if (isInputObjectType(type)) {\n        // Ensure Input Object fields are valid.\n        validateInputFields(context, type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = fields[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var field = _step5.value;\n      // Ensure they are named correctly.\n      validateName(context, field); // Ensure they were defined at most once.\n\n      var fieldNodes = getAllFieldNodes(type, field.name);\n\n      if (fieldNodes.length > 1) {\n        context.reportError(\"Field \".concat(type.name, \".\").concat(field.name, \" can only be defined once.\"), fieldNodes);\n        continue;\n      } // Ensure the type is an output type\n\n\n      if (!isOutputType(field.type)) {\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), getFieldTypeNode(type, field.name));\n      } // Ensure the arguments are valid\n\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = field.args[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var arg = _step6.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per field.\n\n          if (argNames[argName]) {\n            context.reportError(\"Field argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) can only \") + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));\n          }\n\n          argNames[argName] = true; // Ensure the type is an input type\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), getFieldArgTypeNode(type, field.name, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\n\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion7 = true;\n  var _didIteratorError7 = false;\n  var _iteratorError7 = undefined;\n\n  try {\n    for (var _iterator7 = object.getInterfaces()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n      var iface = _step7.value;\n\n      if (!isInterfaceType(iface)) {\n        context.reportError(\"Type \".concat(inspect(object), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getImplementsInterfaceNode(object, iface));\n        continue;\n      }\n\n      if (implementedTypeNames[iface.name]) {\n        context.reportError(\"Type \".concat(object.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(object, iface));\n        continue;\n      }\n\n      implementedTypeNames[iface.name] = true;\n      validateObjectImplementsInterface(context, object, iface);\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n        _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n}\n\nfunction validateObjectImplementsInterface(context, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.\n\n  var _arr = Object.keys(ifaceFieldMap);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var fieldName = _arr[_i];\n    var objectField = objectFieldMap[fieldName];\n    var ifaceField = ifaceFieldMap[fieldName]; // Assert interface field exists on object.\n\n    if (!objectField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \") + \"\".concat(object.name, \" does not provide it.\"), [getFieldNode(iface, fieldName)].concat(getAllNodes(object)));\n      continue;\n    } // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(object.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(objectField.type), \".\"), [getFieldTypeNode(iface, fieldName), getFieldTypeNode(object, fieldName)]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      var _loop = function _loop() {\n        var ifaceArg = _step8.value;\n        var argName = ifaceArg.name;\n        var objectArg = find(objectField.args, function (arg) {\n          return arg.name === argName;\n        }); // Assert interface field arg exists on object field.\n\n        if (!objectArg) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expected but \".concat(object.name, \".\").concat(fieldName, \" does not provide it.\"), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]);\n          return \"continue\";\n        } // Assert interface field arg type matches object field arg type.\n        // (invariant)\n        // TODO: change to contravariant?\n\n\n        if (!isEqualType(ifaceArg.type, objectArg.type)) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(object.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(objectArg.type), \".\"), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);\n        } // TODO: validate default values?\n\n      };\n\n      for (var _iterator8 = ifaceField.args[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      } // Assert additional arguments must not be required.\n\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      var _loop2 = function _loop2() {\n        var objectArg = _step9.value;\n        var argName = objectArg.name;\n        var ifaceArg = find(ifaceField.args, function (arg) {\n          return arg.name === argName;\n        });\n\n        if (!ifaceArg && isRequiredArgument(objectArg)) {\n          context.reportError(\"Object field \".concat(object.name, \".\").concat(fieldName, \" includes required \") + \"argument \".concat(argName, \" that is missing from the Interface field \") + \"\".concat(iface.name, \".\").concat(fieldName, \".\"), [getFieldArgNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);\n        }\n      };\n\n      for (var _iterator9 = objectField.args[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        _loop2();\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion10 = true;\n  var _didIteratorError10 = false;\n  var _iteratorError10 = undefined;\n\n  try {\n    for (var _iterator10 = memberTypes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n      var memberType = _step10.value;\n\n      if (includedTypeNames[memberType.name]) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include type \") + \"\".concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n        continue;\n      }\n\n      includedTypeNames[memberType.name] = true;\n\n      if (!isObjectType(memberType)) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n      }\n    }\n  } catch (err) {\n    _didIteratorError10 = true;\n    _iteratorError10 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n        _iterator10.return();\n      }\n    } finally {\n      if (_didIteratorError10) {\n        throw _iteratorError10;\n      }\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  var _iteratorNormalCompletion11 = true;\n  var _didIteratorError11 = false;\n  var _iteratorError11 = undefined;\n\n  try {\n    for (var _iterator11 = enumValues[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n      var enumValue = _step11.value;\n      var valueName = enumValue.name; // Ensure no duplicates.\n\n      var allNodes = getEnumValueNodes(enumType, valueName);\n\n      if (allNodes && allNodes.length > 1) {\n        context.reportError(\"Enum type \".concat(enumType.name, \" can include value \").concat(valueName, \" only once.\"), allNodes);\n      } // Ensure valid name.\n\n\n      validateName(context, enumValue);\n\n      if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n        context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n      }\n    }\n  } catch (err) {\n    _didIteratorError11 = true;\n    _iteratorError11 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n        _iterator11.return();\n      }\n    } finally {\n      if (_didIteratorError11) {\n        throw _iteratorError11;\n      }\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  var _iteratorNormalCompletion12 = true;\n  var _didIteratorError12 = false;\n  var _iteratorError12 = undefined;\n\n  try {\n    for (var _iterator12 = fields[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n      var field = _step12.value;\n      // Ensure they are named correctly.\n      validateName(context, field); // TODO: Ensure they are unique per field.\n      // Ensure the type is an input type\n\n      if (!isInputType(field.type)) {\n        context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError12 = true;\n    _iteratorError12 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n        _iterator12.return();\n      }\n    } finally {\n      if (_didIteratorError12) {\n        throw _iteratorError12;\n      }\n    }\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  var result = [];\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n\n  try {\n    for (var _iterator13 = getAllNodes(object)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var astNode = _step13.value;\n\n      if (astNode) {\n        var subNodes = getter(astNode);\n\n        if (subNodes) {\n          result = result.concat(subNodes);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getImplementsInterfaceNode(type, iface) {\n  return getAllImplementsInterfaceNodes(type, iface)[0];\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getFieldNode(type, fieldName) {\n  return getAllFieldNodes(type, fieldName)[0];\n}\n\nfunction getAllFieldNodes(type, fieldName) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.fields;\n  }).filter(function (fieldNode) {\n    return fieldNode.name.value === fieldName;\n  });\n}\n\nfunction getFieldTypeNode(type, fieldName) {\n  var fieldNode = getFieldNode(type, fieldName);\n  return fieldNode && fieldNode.type;\n}\n\nfunction getFieldArgNode(type, fieldName, argName) {\n  return getAllFieldArgNodes(type, fieldName, argName)[0];\n}\n\nfunction getAllFieldArgNodes(type, fieldName, argName) {\n  var argNodes = [];\n  var fieldNode = getFieldNode(type, fieldName);\n\n  if (fieldNode && fieldNode.arguments) {\n    var _iteratorNormalCompletion14 = true;\n    var _didIteratorError14 = false;\n    var _iteratorError14 = undefined;\n\n    try {\n      for (var _iterator14 = fieldNode.arguments[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n        var node = _step14.value;\n\n        if (node.name.value === argName) {\n          argNodes.push(node);\n        }\n      }\n    } catch (err) {\n      _didIteratorError14 = true;\n      _iteratorError14 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n          _iterator14.return();\n        }\n      } finally {\n        if (_didIteratorError14) {\n          throw _iteratorError14;\n        }\n      }\n    }\n  }\n\n  return argNodes;\n}\n\nfunction getFieldArgTypeNode(type, fieldName, argName) {\n  var fieldArgNode = getFieldArgNode(type, fieldName, argName);\n  return fieldArgNode && fieldArgNode.type;\n}\n\nfunction getAllDirectiveArgNodes(directive, argName) {\n  return getAllSubNodes(directive, function (directiveNode) {\n    return directiveNode.arguments;\n  }).filter(function (argNode) {\n    return argNode.name.value === argName;\n  });\n}\n\nfunction getDirectiveArgTypeNode(directive, argName) {\n  var argNode = getAllDirectiveArgNodes(directive, argName)[0];\n  return argNode && argNode.type;\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n\nfunction getEnumValueNodes(enumType, valueName) {\n  return getAllSubNodes(enumType, function (enumNode) {\n    return enumNode.values;\n  }).filter(function (valueNode) {\n    return valueNode.name.value === valueName;\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}