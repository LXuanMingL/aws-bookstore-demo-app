{"ast":null,"code":"function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport objectValues from '../jsutils/objectValues';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\nimport { assertValidSDLExtension } from '../validation/validate';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isSchema, GraphQLSchema } from '../type/schema';\nimport { isIntrospectionType } from '../type/introspection';\nimport { isSpecifiedScalarType } from '../type/scalars';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates';\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function extendSchema(schema, documentAST, options) {\n  !isSchema(schema) ? invariant(0, 'Must provide valid GraphQLSchema') : void 0;\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDLExtension(documentAST, schema);\n  } // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefinitions = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      // Sanity check that none of the defined types conflict with the\n      // schema's existing types.\n      var typeName = def.name.value;\n\n      if (schema.getType(typeName)) {\n        throw new GraphQLError(\"Type \\\"\".concat(typeName, \"\\\" already exists in the schema. It cannot also \") + 'be defined in this type definition.', [def]);\n      }\n\n      typeDefinitionMap[typeName] = def;\n    } else if (isTypeExtensionNode(def)) {\n      // Sanity check that this type extension exists within the\n      // schema's existing types.\n      var extendedTypeName = def.name.value;\n      var existingType = schema.getType(extendedTypeName);\n\n      if (!existingType) {\n        throw new GraphQLError(\"Cannot extend type \\\"\".concat(extendedTypeName, \"\\\" because it does not \") + 'exist in the existing schema.', [def]);\n      }\n\n      checkExtensionNode(existingType, def);\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var directiveName = def.name.value;\n      var existingDirective = schema.getDirective(directiveName);\n\n      if (existingDirective) {\n        throw new GraphQLError(\"Directive \\\"\".concat(directiveName, \"\\\" already exists in the schema. It \") + 'cannot be redefined.', [def]);\n      }\n\n      directiveDefinitions.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0 && schemaExtensions.length === 0 && !schemaDef) {\n    return schema;\n  }\n\n  var astBuilder = new ASTDefinitionBuilder(typeDefinitionMap, options, function (typeRef) {\n    var typeName = typeRef.name.value;\n    var existingType = schema.getType(typeName);\n\n    if (existingType) {\n      return extendNamedType(existingType);\n    }\n\n    throw new GraphQLError(\"Unknown type: \\\"\".concat(typeName, \"\\\". Ensure that this type exists \") + 'either in the original schema, or is added in a type definition.', [typeRef]);\n  });\n  var extendTypeCache = Object.create(null); // Get the extended root operation types.\n\n  var operationTypes = {\n    query: extendMaybeNamedType(schema.getQueryType()),\n    mutation: extendMaybeNamedType(schema.getMutationType()),\n    subscription: extendMaybeNamedType(schema.getSubscriptionType())\n  };\n\n  if (schemaDef) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schemaDef.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref2 = _step.value;\n        var operation = _ref2.operation,\n            type = _ref2.type;\n\n        if (operationTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        } // Note: While this could make early assertions to get the correctly\n        // typed values, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n\n\n        operationTypes[operation] = astBuilder.buildType(type);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } // Then, incorporate schema definition and all schema extensions.\n\n\n  for (var _i = 0; _i < schemaExtensions.length; _i++) {\n    var schemaExtension = schemaExtensions[_i];\n\n    if (schemaExtension.operationTypes) {\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n      var _iteratorError12 = undefined;\n\n      try {\n        for (var _iterator12 = schemaExtension.operationTypes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n          var _ref4 = _step12.value;\n          var operation = _ref4.operation,\n              type = _ref4.type;\n\n          if (operationTypes[operation]) {\n            throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n          } // Note: While this could make early assertions to get the correctly\n          // typed values, that would throw immediately while type system\n          // validation with validateSchema() will produce more actionable results.\n\n\n          operationTypes[operation] = astBuilder.buildType(type);\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n            _iterator12.return();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n    }\n  }\n\n  var schemaExtensionASTNodes = schemaExtensions ? schema.extensionASTNodes ? schema.extensionASTNodes.concat(schemaExtensions) : schemaExtensions : schema.extensionASTNodes;\n  var types = objectValues(schema.getTypeMap()).map(function (type) {\n    return extendNamedType(type);\n  }).concat(objectValues(typeDefinitionMap).map(function (type) {\n    return astBuilder.buildType(type);\n  })); // Support both original legacy names and extended legacy names.\n\n  var allowedLegacyNames = schema.__allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.\n\n\n  return new GraphQLSchema(_objectSpread({}, operationTypes, {\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode,\n    extensionASTNodes: schemaExtensionASTNodes,\n    allowedLegacyNames: allowedLegacyNames\n  })); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives().map(extendDirective);\n    !existingDirectives ? invariant(0, 'schema must have default directives') : void 0;\n    return existingDirectives.concat(directiveDefinitions.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n\n  function extendMaybeNamedType(type) {\n    return type ? extendNamedType(type) : null;\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    var name = type.name;\n\n    if (!extendTypeCache[name]) {\n      if (isScalarType(type)) {\n        extendTypeCache[name] = extendScalarType(type);\n      } else if (isObjectType(type)) {\n        extendTypeCache[name] = extendObjectType(type);\n      } else if (isInterfaceType(type)) {\n        extendTypeCache[name] = extendInterfaceType(type);\n      } else if (isUnionType(type)) {\n        extendTypeCache[name] = extendUnionType(type);\n      } else if (isEnumType(type)) {\n        extendTypeCache[name] = extendEnumType(type);\n      } else if (isInputObjectType(type)) {\n        extendTypeCache[name] = extendInputObjectType(type);\n      }\n    }\n\n    return extendTypeCache[name];\n  }\n\n  function extendDirective(directive) {\n    return new GraphQLDirective({\n      name: directive.name,\n      description: directive.description,\n      locations: directive.locations,\n      args: extendArgs(directive.args),\n      astNode: directive.astNode\n    });\n  }\n\n  function extendInputObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLInputObjectType({\n      name: name,\n      description: type.description,\n      fields: function fields() {\n        return extendInputFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendInputFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n\n    var _arr = Object.keys(oldFieldMap);\n\n    for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n      var _fieldName = _arr[_i2];\n      var _field = oldFieldMap[_fieldName];\n      newFieldMap[_fieldName] = {\n        description: _field.description,\n        type: extendType(_field.type),\n        defaultValue: _field.defaultValue,\n        astNode: _field.astNode\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var extension = _step2.value;\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = extension.fields[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var field = _step3.value;\n              var fieldName = field.name.value;\n\n              if (oldFieldMap[fieldName]) {\n                throw new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n\n              newFieldMap[fieldName] = astBuilder.buildInputField(field);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    return newFieldMap;\n  }\n\n  function extendEnumType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLEnumType({\n      name: name,\n      description: type.description,\n      values: extendValueMap(type),\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendValueMap(type) {\n    var newValueMap = Object.create(null);\n    var oldValueMap = keyMap(type.getValues(), function (value) {\n      return value.name;\n    });\n\n    var _arr2 = Object.keys(oldValueMap);\n\n    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {\n      var _valueName = _arr2[_i3];\n      var _value = oldValueMap[_valueName];\n      newValueMap[_valueName] = {\n        name: _value.name,\n        description: _value.description,\n        value: _value.value,\n        deprecationReason: _value.deprecationReason,\n        astNode: _value.astNode\n      };\n    } // If there are any extensions to the values, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = extensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var extension = _step4.value;\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = extension.values[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var value = _step5.value;\n              var valueName = value.name.value;\n\n              if (oldValueMap[valueName]) {\n                throw new GraphQLError(\"Enum value \\\"\".concat(type.name, \".\").concat(valueName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [value]);\n              }\n\n              newValueMap[valueName] = astBuilder.buildEnumValue(value);\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n\n    return newValueMap;\n  }\n\n  function extendScalarType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLScalarType({\n      name: name,\n      description: type.description,\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      serialize: type.serialize,\n      parseValue: type.parseValue,\n      parseLiteral: type.parseLiteral\n    });\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendArgs(args) {\n    return keyValMap(args, function (arg) {\n      return arg.name;\n    }, function (arg) {\n      return {\n        type: extendType(arg.type),\n        defaultValue: arg.defaultValue,\n        description: arg.description,\n        astNode: arg.astNode\n      };\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLUnionType({\n      name: name,\n      description: type.description,\n      types: function types() {\n        return extendPossibleTypes(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendPossibleTypes(type) {\n    var possibleTypes = type.getTypes().map(extendNamedType); // If there are any extensions to the union, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = extensions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var extension = _step6.value;\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = extension.types[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var namedType = _step7.value; // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n\n              possibleTypes.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n\n    return possibleTypes;\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(extendNamedType); // If there are any extensions to the interfaces, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = extensions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var extension = _step8.value;\n          var _iteratorNormalCompletion9 = true;\n          var _didIteratorError9 = false;\n          var _iteratorError9 = undefined;\n\n          try {\n            for (var _iterator9 = extension.interfaces[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n              var namedType = _step9.value; // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n\n              interfaces.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError9 = true;\n            _iteratorError9 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n                _iterator9.return();\n              }\n            } finally {\n              if (_didIteratorError9) {\n                throw _iteratorError9;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n\n    var _arr3 = Object.keys(oldFieldMap);\n\n    for (var _i4 = 0; _i4 < _arr3.length; _i4++) {\n      var _fieldName2 = _arr3[_i4];\n      var _field2 = oldFieldMap[_fieldName2];\n      newFieldMap[_fieldName2] = {\n        description: _field2.description,\n        deprecationReason: _field2.deprecationReason,\n        type: extendType(_field2.type),\n        args: extendArgs(_field2.args),\n        astNode: _field2.astNode,\n        resolve: _field2.resolve\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = extensions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var extension = _step10.value;\n          var _iteratorNormalCompletion11 = true;\n          var _didIteratorError11 = false;\n          var _iteratorError11 = undefined;\n\n          try {\n            for (var _iterator11 = extension.fields[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n              var field = _step11.value;\n              var fieldName = field.name.value;\n\n              if (oldFieldMap[fieldName]) {\n                throw new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n\n              newFieldMap[fieldName] = astBuilder.buildField(field);\n            }\n          } catch (err) {\n            _didIteratorError11 = true;\n            _iteratorError11 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n                _iterator11.return();\n              }\n            } finally {\n              if (_didIteratorError11) {\n                throw _iteratorError11;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n\n    return newFieldMap;\n  }\n\n  function extendType(typeDef) {\n    if (isListType(typeDef)) {\n      return GraphQLList(extendType(typeDef.ofType));\n    }\n\n    if (isNonNullType(typeDef)) {\n      return GraphQLNonNull(extendType(typeDef.ofType));\n    }\n\n    return extendNamedType(typeDef);\n  }\n}\n\nfunction checkExtensionNode(type, node) {\n  switch (node.kind) {\n    case Kind.OBJECT_TYPE_EXTENSION:\n      if (!isObjectType(type)) {\n        throw new GraphQLError(\"Cannot extend non-object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      if (!isInterfaceType(type)) {\n        throw new GraphQLError(\"Cannot extend non-interface type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      if (!isEnumType(type)) {\n        throw new GraphQLError(\"Cannot extend non-enum type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.UNION_TYPE_EXTENSION:\n      if (!isUnionType(type)) {\n        throw new GraphQLError(\"Cannot extend non-union type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      if (!isInputObjectType(type)) {\n        throw new GraphQLError(\"Cannot extend non-input object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n  }\n}","map":{"version":3,"names":["_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","value","defineProperty","configurable","writable","invariant","keyMap","keyValMap","objectValues","ASTDefinitionBuilder","assertValidSDLExtension","GraphQLError","isSchema","GraphQLSchema","isIntrospectionType","isSpecifiedScalarType","isScalarType","isObjectType","isInterfaceType","isUnionType","isListType","isNonNullType","isEnumType","isInputObjectType","GraphQLList","GraphQLNonNull","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLDirective","Kind","isTypeDefinitionNode","isTypeExtensionNode","extendSchema","schema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","typeDefinitionMap","create","typeExtensionsMap","directiveDefinitions","schemaDef","schemaExtensions","definitions","def","SCHEMA_DEFINITION","SCHEMA_EXTENSION","push","typeName","name","getType","extendedTypeName","existingType","checkExtensionNode","existingTypeExtensions","DIRECTIVE_DEFINITION","directiveName","existingDirective","getDirective","astBuilder","typeRef","extendNamedType","extendTypeCache","operationTypes","query","extendMaybeNamedType","getQueryType","mutation","getMutationType","subscription","getSubscriptionType","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","_ref2","operation","type","Error","buildType","err","return","_i","schemaExtension","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_iterator12","_step12","_ref4","schemaExtensionASTNodes","extensionASTNodes","types","getTypeMap","map","allowedLegacyNames","__allowedLegacyNames","directives","getMergedDirectives","astNode","existingDirectives","getDirectives","extendDirective","node","buildDirective","extendScalarType","extendObjectType","extendInterfaceType","extendUnionType","extendEnumType","extendInputObjectType","directive","description","locations","args","extendArgs","fields","extendInputFieldMap","newFieldMap","oldFieldMap","getFields","_arr","_i2","_fieldName","_field","extendType","defaultValue","extensions","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","extension","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","field","fieldName","buildInputField","values","extendValueMap","newValueMap","oldValueMap","getValues","_arr2","_i3","_valueName","_value","deprecationReason","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","valueName","buildEnumValue","serialize","parseValue","parseLiteral","interfaces","extendImplementedInterfaces","extendFieldMap","isTypeOf","arg","resolveType","extendPossibleTypes","possibleTypes","getTypes","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","_step7","namedType","getInterfaces","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_iterator8","_step8","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_iterator9","_step9","_arr3","_i4","_fieldName2","_field2","resolve","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_iterator10","_step10","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_iterator11","_step11","buildField","typeDef","ofType","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","UNION_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION"],"sources":["/home/xl355/341/aws-bookstore-demo-app/assets/node_modules/@aws-amplify/api/node_modules/graphql/utilities/extendSchema.mjs"],"sourcesContent":["function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport objectValues from '../jsutils/objectValues';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\nimport { assertValidSDLExtension } from '../validation/validate';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isSchema, GraphQLSchema } from '../type/schema';\nimport { isIntrospectionType } from '../type/introspection';\nimport { isSpecifiedScalarType } from '../type/scalars';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  !isSchema(schema) ? invariant(0, 'Must provide valid GraphQLSchema') : void 0;\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDLExtension(documentAST, schema);\n  } // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefinitions = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      // Sanity check that none of the defined types conflict with the\n      // schema's existing types.\n      var typeName = def.name.value;\n\n      if (schema.getType(typeName)) {\n        throw new GraphQLError(\"Type \\\"\".concat(typeName, \"\\\" already exists in the schema. It cannot also \") + 'be defined in this type definition.', [def]);\n      }\n\n      typeDefinitionMap[typeName] = def;\n    } else if (isTypeExtensionNode(def)) {\n      // Sanity check that this type extension exists within the\n      // schema's existing types.\n      var extendedTypeName = def.name.value;\n      var existingType = schema.getType(extendedTypeName);\n\n      if (!existingType) {\n        throw new GraphQLError(\"Cannot extend type \\\"\".concat(extendedTypeName, \"\\\" because it does not \") + 'exist in the existing schema.', [def]);\n      }\n\n      checkExtensionNode(existingType, def);\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var directiveName = def.name.value;\n      var existingDirective = schema.getDirective(directiveName);\n\n      if (existingDirective) {\n        throw new GraphQLError(\"Directive \\\"\".concat(directiveName, \"\\\" already exists in the schema. It \") + 'cannot be redefined.', [def]);\n      }\n\n      directiveDefinitions.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0 && schemaExtensions.length === 0 && !schemaDef) {\n    return schema;\n  }\n\n  var astBuilder = new ASTDefinitionBuilder(typeDefinitionMap, options, function (typeRef) {\n    var typeName = typeRef.name.value;\n    var existingType = schema.getType(typeName);\n\n    if (existingType) {\n      return extendNamedType(existingType);\n    }\n\n    throw new GraphQLError(\"Unknown type: \\\"\".concat(typeName, \"\\\". Ensure that this type exists \") + 'either in the original schema, or is added in a type definition.', [typeRef]);\n  });\n  var extendTypeCache = Object.create(null); // Get the extended root operation types.\n\n  var operationTypes = {\n    query: extendMaybeNamedType(schema.getQueryType()),\n    mutation: extendMaybeNamedType(schema.getMutationType()),\n    subscription: extendMaybeNamedType(schema.getSubscriptionType())\n  };\n\n  if (schemaDef) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schemaDef.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref2 = _step.value;\n        var operation = _ref2.operation,\n            type = _ref2.type;\n\n        if (operationTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        } // Note: While this could make early assertions to get the correctly\n        // typed values, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n\n\n        operationTypes[operation] = astBuilder.buildType(type);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } // Then, incorporate schema definition and all schema extensions.\n\n\n  for (var _i = 0; _i < schemaExtensions.length; _i++) {\n    var schemaExtension = schemaExtensions[_i];\n\n    if (schemaExtension.operationTypes) {\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n      var _iteratorError12 = undefined;\n\n      try {\n        for (var _iterator12 = schemaExtension.operationTypes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n          var _ref4 = _step12.value;\n          var operation = _ref4.operation,\n              type = _ref4.type;\n\n          if (operationTypes[operation]) {\n            throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n          } // Note: While this could make early assertions to get the correctly\n          // typed values, that would throw immediately while type system\n          // validation with validateSchema() will produce more actionable results.\n\n\n          operationTypes[operation] = astBuilder.buildType(type);\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n            _iterator12.return();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n    }\n  }\n\n  var schemaExtensionASTNodes = schemaExtensions ? schema.extensionASTNodes ? schema.extensionASTNodes.concat(schemaExtensions) : schemaExtensions : schema.extensionASTNodes;\n  var types = objectValues(schema.getTypeMap()).map(function (type) {\n    return extendNamedType(type);\n  }).concat(objectValues(typeDefinitionMap).map(function (type) {\n    return astBuilder.buildType(type);\n  })); // Support both original legacy names and extended legacy names.\n\n  var allowedLegacyNames = schema.__allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.\n\n\n  return new GraphQLSchema(_objectSpread({}, operationTypes, {\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode,\n    extensionASTNodes: schemaExtensionASTNodes,\n    allowedLegacyNames: allowedLegacyNames\n  })); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives().map(extendDirective);\n    !existingDirectives ? invariant(0, 'schema must have default directives') : void 0;\n    return existingDirectives.concat(directiveDefinitions.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n\n  function extendMaybeNamedType(type) {\n    return type ? extendNamedType(type) : null;\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    var name = type.name;\n\n    if (!extendTypeCache[name]) {\n      if (isScalarType(type)) {\n        extendTypeCache[name] = extendScalarType(type);\n      } else if (isObjectType(type)) {\n        extendTypeCache[name] = extendObjectType(type);\n      } else if (isInterfaceType(type)) {\n        extendTypeCache[name] = extendInterfaceType(type);\n      } else if (isUnionType(type)) {\n        extendTypeCache[name] = extendUnionType(type);\n      } else if (isEnumType(type)) {\n        extendTypeCache[name] = extendEnumType(type);\n      } else if (isInputObjectType(type)) {\n        extendTypeCache[name] = extendInputObjectType(type);\n      }\n    }\n\n    return extendTypeCache[name];\n  }\n\n  function extendDirective(directive) {\n    return new GraphQLDirective({\n      name: directive.name,\n      description: directive.description,\n      locations: directive.locations,\n      args: extendArgs(directive.args),\n      astNode: directive.astNode\n    });\n  }\n\n  function extendInputObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLInputObjectType({\n      name: name,\n      description: type.description,\n      fields: function fields() {\n        return extendInputFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendInputFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n\n    var _arr = Object.keys(oldFieldMap);\n\n    for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n      var _fieldName = _arr[_i2];\n      var _field = oldFieldMap[_fieldName];\n      newFieldMap[_fieldName] = {\n        description: _field.description,\n        type: extendType(_field.type),\n        defaultValue: _field.defaultValue,\n        astNode: _field.astNode\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var extension = _step2.value;\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = extension.fields[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var field = _step3.value;\n              var fieldName = field.name.value;\n\n              if (oldFieldMap[fieldName]) {\n                throw new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n\n              newFieldMap[fieldName] = astBuilder.buildInputField(field);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    return newFieldMap;\n  }\n\n  function extendEnumType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLEnumType({\n      name: name,\n      description: type.description,\n      values: extendValueMap(type),\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendValueMap(type) {\n    var newValueMap = Object.create(null);\n    var oldValueMap = keyMap(type.getValues(), function (value) {\n      return value.name;\n    });\n\n    var _arr2 = Object.keys(oldValueMap);\n\n    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {\n      var _valueName = _arr2[_i3];\n      var _value = oldValueMap[_valueName];\n      newValueMap[_valueName] = {\n        name: _value.name,\n        description: _value.description,\n        value: _value.value,\n        deprecationReason: _value.deprecationReason,\n        astNode: _value.astNode\n      };\n    } // If there are any extensions to the values, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = extensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var extension = _step4.value;\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = extension.values[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var value = _step5.value;\n              var valueName = value.name.value;\n\n              if (oldValueMap[valueName]) {\n                throw new GraphQLError(\"Enum value \\\"\".concat(type.name, \".\").concat(valueName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [value]);\n              }\n\n              newValueMap[valueName] = astBuilder.buildEnumValue(value);\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n\n    return newValueMap;\n  }\n\n  function extendScalarType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLScalarType({\n      name: name,\n      description: type.description,\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      serialize: type.serialize,\n      parseValue: type.parseValue,\n      parseLiteral: type.parseLiteral\n    });\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendArgs(args) {\n    return keyValMap(args, function (arg) {\n      return arg.name;\n    }, function (arg) {\n      return {\n        type: extendType(arg.type),\n        defaultValue: arg.defaultValue,\n        description: arg.description,\n        astNode: arg.astNode\n      };\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLUnionType({\n      name: name,\n      description: type.description,\n      types: function types() {\n        return extendPossibleTypes(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendPossibleTypes(type) {\n    var possibleTypes = type.getTypes().map(extendNamedType); // If there are any extensions to the union, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = extensions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var extension = _step6.value;\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = extension.types[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var namedType = _step7.value;\n              // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n              possibleTypes.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n\n    return possibleTypes;\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(extendNamedType); // If there are any extensions to the interfaces, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = extensions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var extension = _step8.value;\n          var _iteratorNormalCompletion9 = true;\n          var _didIteratorError9 = false;\n          var _iteratorError9 = undefined;\n\n          try {\n            for (var _iterator9 = extension.interfaces[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n              var namedType = _step9.value;\n              // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n              interfaces.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError9 = true;\n            _iteratorError9 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n                _iterator9.return();\n              }\n            } finally {\n              if (_didIteratorError9) {\n                throw _iteratorError9;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n\n    var _arr3 = Object.keys(oldFieldMap);\n\n    for (var _i4 = 0; _i4 < _arr3.length; _i4++) {\n      var _fieldName2 = _arr3[_i4];\n      var _field2 = oldFieldMap[_fieldName2];\n      newFieldMap[_fieldName2] = {\n        description: _field2.description,\n        deprecationReason: _field2.deprecationReason,\n        type: extendType(_field2.type),\n        args: extendArgs(_field2.args),\n        astNode: _field2.astNode,\n        resolve: _field2.resolve\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = extensions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var extension = _step10.value;\n          var _iteratorNormalCompletion11 = true;\n          var _didIteratorError11 = false;\n          var _iteratorError11 = undefined;\n\n          try {\n            for (var _iterator11 = extension.fields[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n              var field = _step11.value;\n              var fieldName = field.name.value;\n\n              if (oldFieldMap[fieldName]) {\n                throw new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n\n              newFieldMap[fieldName] = astBuilder.buildField(field);\n            }\n          } catch (err) {\n            _didIteratorError11 = true;\n            _iteratorError11 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n                _iterator11.return();\n              }\n            } finally {\n              if (_didIteratorError11) {\n                throw _iteratorError11;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n\n    return newFieldMap;\n  }\n\n  function extendType(typeDef) {\n    if (isListType(typeDef)) {\n      return GraphQLList(extendType(typeDef.ofType));\n    }\n\n    if (isNonNullType(typeDef)) {\n      return GraphQLNonNull(extendType(typeDef.ofType));\n    }\n\n    return extendNamedType(typeDef);\n  }\n}\n\nfunction checkExtensionNode(type, node) {\n  switch (node.kind) {\n    case Kind.OBJECT_TYPE_EXTENSION:\n      if (!isObjectType(type)) {\n        throw new GraphQLError(\"Cannot extend non-object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      if (!isInterfaceType(type)) {\n        throw new GraphQLError(\"Cannot extend non-interface type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      if (!isEnumType(type)) {\n        throw new GraphQLError(\"Cannot extend non-enum type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.UNION_TYPE_EXTENSION:\n      if (!isUnionType(type)) {\n        throw new GraphQLError(\"Cannot extend non-union type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      if (!isInputObjectType(type)) {\n        throw new GraphQLError(\"Cannot extend non-input object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}