{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { parseValue } from '../language/parser';\nimport { GraphQLSchema } from '../type/schema';\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { introspectionTypes, TypeKind } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  // Get the schema from the introspection result.\n  var schemaIntrospection = introspection.__schema; // Converts the list of types into a keyMap based on the type names.\n\n  var typeIntrospectionMap = keyMap(schemaIntrospection.types, function (type) {\n    return type.name;\n  }); // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n\n  var typeDefCache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n    return type.name;\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    if (!typeRef.name) {\n      throw new Error('Unknown type reference: ' + JSON.stringify(typeRef));\n    }\n\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    if (typeDefCache[typeName]) {\n      return typeDefCache[typeName];\n    }\n\n    var typeIntrospection = typeIntrospectionMap[typeName];\n\n    if (!typeIntrospection) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure \") + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n\n    var typeDef = buildType(typeIntrospection);\n    typeDefCache[typeName] = typeDef;\n    return typeDef;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n    !isInputType(type) ? invariant(0, 'Introspection must provide input type for arguments.') : void 0;\n    return type;\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n    !isOutputType(type) ? invariant(0, 'Introspection must provide output type for fields.') : void 0;\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    return assertObjectType(type);\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    return assertInterfaceType(type);\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type && type.name && type.kind) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    throw new Error('Invalid or incomplete introspection result. Ensure that a full ' + 'introspection query is used in order to build a client schema:' + JSON.stringify(type));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    if (!objectIntrospection.interfaces) {\n      throw new Error('Introspection result missing interfaces: ' + JSON.stringify(objectIntrospection));\n    }\n\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: objectIntrospection.interfaces.map(getInterfaceType),\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      throw new Error('Introspection result missing possibleTypes: ' + JSON.stringify(unionIntrospection));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: unionIntrospection.possibleTypes.map(getObjectType)\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      throw new Error('Introspection result missing enumValues: ' + JSON.stringify(enumIntrospection));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      throw new Error('Introspection result missing inputFields: ' + JSON.stringify(inputObjectIntrospection));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error('Introspection result missing fields: ' + JSON.stringify(typeIntrospection));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      if (!fieldIntrospection.args) {\n        throw new Error('Introspection result missing field args: ' + JSON.stringify(fieldIntrospection));\n      }\n\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      throw new Error('Introspection result missing directive args: ' + JSON.stringify(directiveIntrospection));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  } // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n\n  var types = schemaIntrospection.types.map(function (typeIntrospection) {\n    return getNamedType(typeIntrospection.name);\n  }); // Get the root Query, Mutation, and Subscription types.\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: directives,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n}","map":{"version":3,"names":["invariant","keyMap","keyValMap","valueFromAST","parseValue","GraphQLSchema","isInputType","isOutputType","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","assertNullableType","assertObjectType","assertInterfaceType","GraphQLDirective","introspectionTypes","TypeKind","specifiedScalarTypes","buildClientSchema","introspection","options","schemaIntrospection","__schema","typeIntrospectionMap","types","type","name","typeDefCache","concat","getType","typeRef","kind","LIST","itemRef","ofType","Error","NON_NULL","nullableRef","nullableType","JSON","stringify","getNamedType","typeName","typeIntrospection","typeDef","buildType","getInputType","getOutputType","getObjectType","getInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","scalarIntrospection","description","serialize","value","objectIntrospection","interfaces","map","fields","buildFieldDefMap","interfaceIntrospection","unionIntrospection","possibleTypes","enumIntrospection","enumValues","values","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","buildInputValueDefMap","fieldIntrospection","args","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","undefined","buildDirective","directiveIntrospection","locations","slice","queryType","mutationType","subscriptionType","directives","query","mutation","subscription","assumeValid","allowedLegacyNames"],"sources":["/home/xl355/341/aws-bookstore-demo-app/assets/node_modules/@aws-amplify/api/node_modules/graphql/utilities/buildClientSchema.mjs"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { parseValue } from '../language/parser';\nimport { GraphQLSchema } from '../type/schema';\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { introspectionTypes, TypeKind } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\nexport function buildClientSchema(introspection, options) {\n  // Get the schema from the introspection result.\n  var schemaIntrospection = introspection.__schema; // Converts the list of types into a keyMap based on the type names.\n\n  var typeIntrospectionMap = keyMap(schemaIntrospection.types, function (type) {\n    return type.name;\n  }); // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n\n  var typeDefCache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n    return type.name;\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    if (!typeRef.name) {\n      throw new Error('Unknown type reference: ' + JSON.stringify(typeRef));\n    }\n\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    if (typeDefCache[typeName]) {\n      return typeDefCache[typeName];\n    }\n\n    var typeIntrospection = typeIntrospectionMap[typeName];\n\n    if (!typeIntrospection) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure \") + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n\n    var typeDef = buildType(typeIntrospection);\n    typeDefCache[typeName] = typeDef;\n    return typeDef;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n    !isInputType(type) ? invariant(0, 'Introspection must provide input type for arguments.') : void 0;\n    return type;\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n    !isOutputType(type) ? invariant(0, 'Introspection must provide output type for fields.') : void 0;\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    return assertObjectType(type);\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    return assertInterfaceType(type);\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type && type.name && type.kind) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    throw new Error('Invalid or incomplete introspection result. Ensure that a full ' + 'introspection query is used in order to build a client schema:' + JSON.stringify(type));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    if (!objectIntrospection.interfaces) {\n      throw new Error('Introspection result missing interfaces: ' + JSON.stringify(objectIntrospection));\n    }\n\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: objectIntrospection.interfaces.map(getInterfaceType),\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      throw new Error('Introspection result missing possibleTypes: ' + JSON.stringify(unionIntrospection));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: unionIntrospection.possibleTypes.map(getObjectType)\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      throw new Error('Introspection result missing enumValues: ' + JSON.stringify(enumIntrospection));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      throw new Error('Introspection result missing inputFields: ' + JSON.stringify(inputObjectIntrospection));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error('Introspection result missing fields: ' + JSON.stringify(typeIntrospection));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      if (!fieldIntrospection.args) {\n        throw new Error('Introspection result missing field args: ' + JSON.stringify(fieldIntrospection));\n      }\n\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      throw new Error('Introspection result missing directive args: ' + JSON.stringify(directiveIntrospection));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  } // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n\n  var types = schemaIntrospection.types.map(function (typeIntrospection) {\n    return getNamedType(typeIntrospection.name);\n  }); // Get the root Query, Mutation, and Subscription types.\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: directives,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}