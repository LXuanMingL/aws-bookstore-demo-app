{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { assertValidSDL } from '../validation/validate';\nimport blockStringValue from '../language/blockStringValue';\nimport { TokenKind } from '../language/lexer';\nimport { parse } from '../language/parser';\nimport { getDirectiveValues } from '../execution/values';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode } from '../language/predicates';\nimport { GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\nimport { introspectionTypes } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { GraphQLSchema } from '../type/schema';\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function buildASTSchema(documentAST, options) {\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDL(documentAST);\n  }\n\n  var schemaDef;\n  var typeDefs = [];\n  var nodeMap = Object.create(null);\n  var directiveDefs = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (isTypeDefinitionNode(def)) {\n      var typeName = def.name.value;\n\n      if (nodeMap[typeName]) {\n        throw new Error(\"Type \\\"\".concat(typeName, \"\\\" was defined more than once.\"));\n      }\n\n      typeDefs.push(def);\n      nodeMap[typeName] = def;\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: nodeMap.Query,\n    mutation: nodeMap.Mutation,\n    subscription: nodeMap.Subscription\n  };\n  var definitionBuilder = new ASTDefinitionBuilder(nodeMap, options, function (typeRef) {\n    throw new Error(\"Type \\\"\".concat(typeRef.name.value, \"\\\" not found in document.\"));\n  });\n  var directives = directiveDefs.map(function (def) {\n    return definitionBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  } // Note: While this could make early assertions to get the correctly\n  // typed values below, that would throw immediately while type system\n  // validation with validateSchema() will produce more actionable results.\n\n\n  return new GraphQLSchema({\n    query: operationTypes.query ? definitionBuilder.buildType(operationTypes.query) : null,\n    mutation: operationTypes.mutation ? definitionBuilder.buildType(operationTypes.mutation) : null,\n    subscription: operationTypes.subscription ? definitionBuilder.buildType(operationTypes.subscription) : null,\n    types: typeDefs.map(function (node) {\n      return definitionBuilder.buildType(node);\n    }),\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n\n  function getOperationTypes(schema) {\n    var opTypes = {};\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schema.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var operationType = _step.value;\n        var _typeName = operationType.type.name.value;\n        var operation = operationType.operation;\n\n        if (opTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        }\n\n        if (!nodeMap[_typeName]) {\n          throw new Error(\"Specified \".concat(operation, \" type \\\"\").concat(_typeName, \"\\\" not found in document.\"));\n        }\n\n        opTypes[operation] = operationType.type;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return opTypes;\n  }\n}\nexport var ASTDefinitionBuilder = /*#__PURE__*/function () {\n  function ASTDefinitionBuilder(typeDefinitionsMap, options, resolveType) {\n    _defineProperty(this, \"_typeDefinitionsMap\", void 0);\n\n    _defineProperty(this, \"_options\", void 0);\n\n    _defineProperty(this, \"_resolveType\", void 0);\n\n    _defineProperty(this, \"_cache\", void 0);\n\n    this._typeDefinitionsMap = typeDefinitionsMap;\n    this._options = options;\n    this._resolveType = resolveType; // Initialize to the GraphQL built in scalars and introspection types.\n\n    this._cache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n      return type.name;\n    });\n  }\n\n  var _proto = ASTDefinitionBuilder.prototype;\n\n  _proto.buildType = function buildType(node) {\n    var typeName = node.name.value;\n\n    if (!this._cache[typeName]) {\n      if (node.kind === Kind.NAMED_TYPE) {\n        var defNode = this._typeDefinitionsMap[typeName];\n        this._cache[typeName] = defNode ? this._makeSchemaDef(defNode) : this._resolveType(node);\n      } else {\n        this._cache[typeName] = this._makeSchemaDef(node);\n      }\n    }\n\n    return this._cache[typeName];\n  };\n\n  _proto._buildWrappedType = function _buildWrappedType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return GraphQLList(this._buildWrappedType(typeNode.type));\n    }\n\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      return GraphQLNonNull( // Note: GraphQLNonNull constructor validates this type\n      this._buildWrappedType(typeNode.type));\n    }\n\n    return this.buildType(typeNode);\n  };\n\n  _proto.buildDirective = function buildDirective(directiveNode) {\n    return new GraphQLDirective({\n      name: directiveNode.name.value,\n      description: getDescription(directiveNode, this._options),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && this._makeInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  };\n\n  _proto.buildField = function buildField(field) {\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this._buildWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: field.arguments && this._makeInputValues(field.arguments),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n\n  _proto.buildInputField = function buildInputField(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    var type = this._buildWrappedType(value.type);\n\n    return {\n      name: value.name.value,\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildEnumValue = function buildEnumValue(value) {\n    return {\n      description: getDescription(value, this._options),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    };\n  };\n\n  _proto._makeSchemaDef = function _makeSchemaDef(def) {\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(def);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(def);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(def);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(def);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(def);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(def);\n\n      default:\n        throw new Error(\"Type kind \\\"\".concat(def.kind, \"\\\" not supported.\"));\n    }\n  };\n\n  _proto._makeTypeDef = function _makeTypeDef(def) {\n    var _this = this;\n\n    var interfaces = def.interfaces;\n    return new GraphQLObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this._makeFieldDefMap(def);\n      },\n      // Note: While this could make early assertions to get the correctly\n      // typed values, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      interfaces: interfaces ? function () {\n        return interfaces.map(function (ref) {\n          return _this.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n\n  _proto._makeFieldDefMap = function _makeFieldDefMap(def) {\n    var _this2 = this;\n\n    return def.fields ? keyValMap(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return _this2.buildField(field);\n    }) : {};\n  };\n\n  _proto._makeInputValues = function _makeInputValues(values) {\n    var _this3 = this;\n\n    return keyValMap(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      return _this3.buildInputField(value);\n    });\n  };\n\n  _proto._makeInterfaceDef = function _makeInterfaceDef(def) {\n    var _this4 = this;\n\n    return new GraphQLInterfaceType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this4._makeFieldDefMap(def);\n      },\n      astNode: def\n    });\n  };\n\n  _proto._makeEnumDef = function _makeEnumDef(def) {\n    return new GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      values: this._makeValueDefMap(def),\n      astNode: def\n    });\n  };\n\n  _proto._makeValueDefMap = function _makeValueDefMap(def) {\n    var _this5 = this;\n\n    return def.values ? keyValMap(def.values, function (enumValue) {\n      return enumValue.name.value;\n    }, function (enumValue) {\n      return _this5.buildEnumValue(enumValue);\n    }) : {};\n  };\n\n  _proto._makeUnionDef = function _makeUnionDef(def) {\n    var _this6 = this;\n\n    var types = def.types;\n    return new GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      // Note: While this could make assertions to get the correctly typed\n      // values below, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      types: types ? function () {\n        return types.map(function (ref) {\n          return _this6.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n\n  _proto._makeScalarDef = function _makeScalarDef(def) {\n    return new GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      astNode: def,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  };\n\n  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this7 = this;\n\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return def.fields ? _this7._makeInputValues(def.fields) : {};\n      },\n      astNode: def\n    });\n  };\n\n  return ASTDefinitionBuilder;\n}();\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return blockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nexport function buildSchema(source, options) {\n  return buildASTSchema(parse(source, options), options);\n}","map":{"version":3,"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","invariant","keyMap","keyValMap","valueFromAST","assertValidSDL","blockStringValue","TokenKind","parse","getDirectiveValues","Kind","isTypeDefinitionNode","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","GraphQLDirective","GraphQLSkipDirective","GraphQLIncludeDirective","GraphQLDeprecatedDirective","introspectionTypes","specifiedScalarTypes","GraphQLSchema","buildASTSchema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","schemaDef","typeDefs","nodeMap","create","directiveDefs","i","definitions","length","def","SCHEMA_DEFINITION","typeName","name","Error","concat","push","DIRECTIVE_DEFINITION","operationTypes","getOperationTypes","query","Query","mutation","Mutation","subscription","Subscription","definitionBuilder","ASTDefinitionBuilder","typeRef","directives","map","buildDirective","some","directive","buildType","types","node","astNode","allowedLegacyNames","schema","opTypes","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","operationType","_typeName","type","operation","err","return","typeDefinitionsMap","resolveType","_typeDefinitionsMap","_options","_resolveType","_cache","_proto","prototype","NAMED_TYPE","defNode","_makeSchemaDef","_buildWrappedType","typeNode","LIST_TYPE","NON_NULL_TYPE","directiveNode","description","getDescription","locations","args","arguments","_makeInputValues","buildField","field","deprecationReason","getDeprecationReason","buildInputField","defaultValue","buildEnumValue","OBJECT_TYPE_DEFINITION","_makeTypeDef","INTERFACE_TYPE_DEFINITION","_makeInterfaceDef","ENUM_TYPE_DEFINITION","_makeEnumDef","UNION_TYPE_DEFINITION","_makeUnionDef","SCALAR_TYPE_DEFINITION","_makeScalarDef","INPUT_OBJECT_TYPE_DEFINITION","_makeInputObjectDef","_this","interfaces","fields","_makeFieldDefMap","ref","_this2","values","_this3","_this4","_makeValueDefMap","_this5","enumValue","_this6","serialize","_this7","deprecated","reason","commentDescriptions","rawValue","getLeadingCommentBlock","loc","comments","token","startToken","prev","COMMENT","line","String","reverse","join","buildSchema","source"],"sources":["/home/xl355/341/aws-bookstore-demo-app/assets/node_modules/@aws-amplify/api/node_modules/graphql/utilities/buildASTSchema.mjs"],"sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { assertValidSDL } from '../validation/validate';\nimport blockStringValue from '../language/blockStringValue';\nimport { TokenKind } from '../language/lexer';\nimport { parse } from '../language/parser';\nimport { getDirectiveValues } from '../execution/values';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode } from '../language/predicates';\nimport { GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\nimport { introspectionTypes } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { GraphQLSchema } from '../type/schema';\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDL(documentAST);\n  }\n\n  var schemaDef;\n  var typeDefs = [];\n  var nodeMap = Object.create(null);\n  var directiveDefs = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (isTypeDefinitionNode(def)) {\n      var typeName = def.name.value;\n\n      if (nodeMap[typeName]) {\n        throw new Error(\"Type \\\"\".concat(typeName, \"\\\" was defined more than once.\"));\n      }\n\n      typeDefs.push(def);\n      nodeMap[typeName] = def;\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: nodeMap.Query,\n    mutation: nodeMap.Mutation,\n    subscription: nodeMap.Subscription\n  };\n  var definitionBuilder = new ASTDefinitionBuilder(nodeMap, options, function (typeRef) {\n    throw new Error(\"Type \\\"\".concat(typeRef.name.value, \"\\\" not found in document.\"));\n  });\n  var directives = directiveDefs.map(function (def) {\n    return definitionBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  } // Note: While this could make early assertions to get the correctly\n  // typed values below, that would throw immediately while type system\n  // validation with validateSchema() will produce more actionable results.\n\n\n  return new GraphQLSchema({\n    query: operationTypes.query ? definitionBuilder.buildType(operationTypes.query) : null,\n    mutation: operationTypes.mutation ? definitionBuilder.buildType(operationTypes.mutation) : null,\n    subscription: operationTypes.subscription ? definitionBuilder.buildType(operationTypes.subscription) : null,\n    types: typeDefs.map(function (node) {\n      return definitionBuilder.buildType(node);\n    }),\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n\n  function getOperationTypes(schema) {\n    var opTypes = {};\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schema.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var operationType = _step.value;\n        var _typeName = operationType.type.name.value;\n        var operation = operationType.operation;\n\n        if (opTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        }\n\n        if (!nodeMap[_typeName]) {\n          throw new Error(\"Specified \".concat(operation, \" type \\\"\").concat(_typeName, \"\\\" not found in document.\"));\n        }\n\n        opTypes[operation] = operationType.type;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return opTypes;\n  }\n}\nexport var ASTDefinitionBuilder =\n/*#__PURE__*/\nfunction () {\n  function ASTDefinitionBuilder(typeDefinitionsMap, options, resolveType) {\n    _defineProperty(this, \"_typeDefinitionsMap\", void 0);\n\n    _defineProperty(this, \"_options\", void 0);\n\n    _defineProperty(this, \"_resolveType\", void 0);\n\n    _defineProperty(this, \"_cache\", void 0);\n\n    this._typeDefinitionsMap = typeDefinitionsMap;\n    this._options = options;\n    this._resolveType = resolveType; // Initialize to the GraphQL built in scalars and introspection types.\n\n    this._cache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n      return type.name;\n    });\n  }\n\n  var _proto = ASTDefinitionBuilder.prototype;\n\n  _proto.buildType = function buildType(node) {\n    var typeName = node.name.value;\n\n    if (!this._cache[typeName]) {\n      if (node.kind === Kind.NAMED_TYPE) {\n        var defNode = this._typeDefinitionsMap[typeName];\n        this._cache[typeName] = defNode ? this._makeSchemaDef(defNode) : this._resolveType(node);\n      } else {\n        this._cache[typeName] = this._makeSchemaDef(node);\n      }\n    }\n\n    return this._cache[typeName];\n  };\n\n  _proto._buildWrappedType = function _buildWrappedType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return GraphQLList(this._buildWrappedType(typeNode.type));\n    }\n\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      return GraphQLNonNull( // Note: GraphQLNonNull constructor validates this type\n      this._buildWrappedType(typeNode.type));\n    }\n\n    return this.buildType(typeNode);\n  };\n\n  _proto.buildDirective = function buildDirective(directiveNode) {\n    return new GraphQLDirective({\n      name: directiveNode.name.value,\n      description: getDescription(directiveNode, this._options),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && this._makeInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  };\n\n  _proto.buildField = function buildField(field) {\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this._buildWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: field.arguments && this._makeInputValues(field.arguments),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n\n  _proto.buildInputField = function buildInputField(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    var type = this._buildWrappedType(value.type);\n\n    return {\n      name: value.name.value,\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildEnumValue = function buildEnumValue(value) {\n    return {\n      description: getDescription(value, this._options),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    };\n  };\n\n  _proto._makeSchemaDef = function _makeSchemaDef(def) {\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(def);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(def);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(def);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(def);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(def);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(def);\n\n      default:\n        throw new Error(\"Type kind \\\"\".concat(def.kind, \"\\\" not supported.\"));\n    }\n  };\n\n  _proto._makeTypeDef = function _makeTypeDef(def) {\n    var _this = this;\n\n    var interfaces = def.interfaces;\n    return new GraphQLObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this._makeFieldDefMap(def);\n      },\n      // Note: While this could make early assertions to get the correctly\n      // typed values, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      interfaces: interfaces ? function () {\n        return interfaces.map(function (ref) {\n          return _this.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n\n  _proto._makeFieldDefMap = function _makeFieldDefMap(def) {\n    var _this2 = this;\n\n    return def.fields ? keyValMap(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return _this2.buildField(field);\n    }) : {};\n  };\n\n  _proto._makeInputValues = function _makeInputValues(values) {\n    var _this3 = this;\n\n    return keyValMap(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      return _this3.buildInputField(value);\n    });\n  };\n\n  _proto._makeInterfaceDef = function _makeInterfaceDef(def) {\n    var _this4 = this;\n\n    return new GraphQLInterfaceType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this4._makeFieldDefMap(def);\n      },\n      astNode: def\n    });\n  };\n\n  _proto._makeEnumDef = function _makeEnumDef(def) {\n    return new GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      values: this._makeValueDefMap(def),\n      astNode: def\n    });\n  };\n\n  _proto._makeValueDefMap = function _makeValueDefMap(def) {\n    var _this5 = this;\n\n    return def.values ? keyValMap(def.values, function (enumValue) {\n      return enumValue.name.value;\n    }, function (enumValue) {\n      return _this5.buildEnumValue(enumValue);\n    }) : {};\n  };\n\n  _proto._makeUnionDef = function _makeUnionDef(def) {\n    var _this6 = this;\n\n    var types = def.types;\n    return new GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      // Note: While this could make assertions to get the correctly typed\n      // values below, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      types: types ? function () {\n        return types.map(function (ref) {\n          return _this6.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n\n  _proto._makeScalarDef = function _makeScalarDef(def) {\n    return new GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      astNode: def,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  };\n\n  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this7 = this;\n\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return def.fields ? _this7._makeInputValues(def.fields) : {};\n      },\n      astNode: def\n    });\n  };\n\n  return ASTDefinitionBuilder;\n}();\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return blockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nexport function buildSchema(source, options) {\n  return buildASTSchema(parse(source, options), options);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}